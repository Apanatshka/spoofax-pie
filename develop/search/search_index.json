{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spoofax 3 \u00b6 Spoofax 3 is a modular and incremental textual language workbench running on the JVM : a collection of tools and Java libraries that enable the development of textual languages, embeddable into batch compilers, code editors and IDEs, or custom applications. It is a reimplementation of Spoofax 2 , with the goal of being more modular, flexible, and correctly incremental. This documentation website aims to cover language development with Spoofax 3, development of the language workbench itself (e.g., meta-language development), and development of this documentation. Currently, Spoofax 3 is experimental and still a work-in-progress. Therefore, it does not have a stable API, lacks documentation and test coverage, and has not yet been applied to real-world use cases. If you are looking for a more mature alternative, see Spoofax 2 , which Spoofax 3 is based on. The documentation for Spoofax 3 is split into five parts: Tutorials : hands-on tutorials to getting you started with Spoofax 3. How-to guides : step-by-step guides showing how to implement certain features or how to solve common problems. (Under construction) Reference : technical reference describing the various facets of Spoofax 3. Background : background information and discussion on various key topics. Releases : download links, changelogs, and migration guides.","title":"Home"},{"location":"#spoofax-3","text":"Spoofax 3 is a modular and incremental textual language workbench running on the JVM : a collection of tools and Java libraries that enable the development of textual languages, embeddable into batch compilers, code editors and IDEs, or custom applications. It is a reimplementation of Spoofax 2 , with the goal of being more modular, flexible, and correctly incremental. This documentation website aims to cover language development with Spoofax 3, development of the language workbench itself (e.g., meta-language development), and development of this documentation. Currently, Spoofax 3 is experimental and still a work-in-progress. Therefore, it does not have a stable API, lacks documentation and test coverage, and has not yet been applied to real-world use cases. If you are looking for a more mature alternative, see Spoofax 2 , which Spoofax 3 is based on. The documentation for Spoofax 3 is split into five parts: Tutorials : hands-on tutorials to getting you started with Spoofax 3. How-to guides : step-by-step guides showing how to implement certain features or how to solve common problems. (Under construction) Reference : technical reference describing the various facets of Spoofax 3. Background : background information and discussion on various key topics. Releases : download links, changelogs, and migration guides.","title":"Spoofax 3"},{"location":"info/","text":"Macros Plugin Environment \u00b6 General List \u00b6 All available variables and filters within the macros plugin: Variable Type Content extra dict os [ dict ], download [ dict ] config Config config_file_path = '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml', site_name = 'Spoofax 3', nav = [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/anatomy_language_implementation.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}], pages [ NoneType ], site_url = '', site_description = 'Spoofax 3 documentation website', site_author [ NoneType ], theme [ Theme ], docs_dir = '/home/runner/work/spoofax-pie/spoofax-pie/docs', site_dir = '/home/runner/work/spoofax-pie/spoofax-pie/site', copyright [ NoneType ], google_analytics [ NoneType ], dev_addr [ Address ], use_directory_urls = True, repo_url = 'https://github.com/metaborg/spoofax-pie/', repo_name = 'metaborg/spoofax-pie', edit_uri = 'edit/master/docs/', extra_css = ['extra.css'], extra_javascript = [], extra_templates = [], markdown_extensions = ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'], mdx_configs [ dict ], strict = False, remote_branch = 'gh-pages', remote_name = 'origin', extra [ SubConfig ], plugins [ PluginCollection ] environment dict system = 'Linux', system_version = '5.4.0-1047-azure', python_version = '3.8.10', mkdocs_version = '1.1.2', macros_plugin_version = '0.5.5', jinja2_version = '3.0.1' plugin Config module_name = 'main', modules = [], include_dir = '', include_yaml = [], j2_block_start_string = '', j2_block_end_string = '', j2_variable_start_string = '', j2_variable_end_string = '', verbose = False git dict status = True, date [ datetime ], short_commit = 'cd697bf', commit = 'cd697bf821146f90d47970bf87c8b9b92a1bae49', author = 'Gabriel Konat', tag = '', date_ISO = '2021-05-27 16:49:09 +0200', message = 'Add warning about invalid characters.', raw = 'commit cd697bf821146f90d47970bf87c8b9b92a1bae49\\nAuthor: Gabriel Konat \\nDate: Thu May 27 16:49:09 2021 +0200\\n\\n Add warning about invalid characters.', root_dir = '/home/runner/work/spoofax-pie/spoofax-pie' context function ( obj, e ) Default mkdocs_macro List the defined variables macros_info function ( ) Test/debug function: list useful documentation on the mkdocs_macro environment. now function ( ) Get the current time (returns a datetime object). Used alone, it provides a timestamp. To get the year use now().year , for the month number now().month , etc. fix_url function ( url, r ) If url is relative, fix it so that it points to the docs diretory. This is necessary because relative links in markdown must be adapted in html ('img/foo.png' => '../img/img.png'). os dict windows = ':fontawesome-brands-windows: Windows', linux = ':fontawesome-brands-linux: Linux', macos = ':fontawesome-brands-apple: macOS' download dict dev [ dict ] filters dict pretty [ function ] filters_builtin dict abs [ builtin_function_or_method ], attr [ function ], batch [ function ], capitalize [ function ], center [ function ], count [ builtin_function_or_method ], d [ function ], default [ function ], dictsort [ function ], e [ builtin_function_or_method ], escape [ builtin_function_or_method ], filesizeformat [ function ], first [ function ], float [ function ], forceescape [ function ], format [ function ], groupby [ function ], indent [ function ], int [ function ], join [ function ], last [ function ], length [ builtin_function_or_method ], list [ function ], lower [ function ], map [ function ], min [ function ], max [ function ], pprint [ function ], random [ function ], reject [ function ], rejectattr [ function ], replace [ function ], reverse [ function ], round [ function ], safe [ function ], select [ function ], selectattr [ function ], slice [ function ], sort [ function ], string [ builtin_function_or_method ], striptags [ function ], sum [ function ], title [ function ], trim [ function ], truncate [ function ], unique [ function ], upper [ function ], urlencode [ function ], urlize [ function ], wordcount [ function ], wordwrap [ function ], xmlattr [ function ], tojson [ function ] navigation Navigation Page(title='Home', url='.') Section(title='Tutorials') Page(title=[blank], url='tutorial/install/') Page(title=[blank], url='tutorial/create_language_project/') Section(title='Reference') Page(title=[blank], url='reference/anatomy_language_implementation/') Section(title='Background') Page(title=[blank], url='background/documentation/') Page(title=[blank], url='background/motivation/') Page(title=[blank], url='background/key_ideas/') Page(title=[blank], url='background/status/') Section(title='Releases') Page(title=[blank], url='release/download/') page Page Page(title='Info', url='info/') Config Information \u00b6 Standard MkDocs configuration information. Do not try to modify. e.g. {{ config.docs_dir }} See also the MkDocs documentation on the config object . Variable Type Content config_file_path str '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml' site_name str 'Spoofax 3' nav list [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/anatomy_language_implementation.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}] pages NoneType None site_url str '' site_description str 'Spoofax 3 documentation website' site_author NoneType None theme Theme Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.8.10/x64/lib/python3.8/site-packages/material', '/opt/hostedtoolcache/Python/3.8.10/x64/lib/python3.8/site-packages/mkdocs/templates'], static_templates=['sitemap.xml', '404.html'], language='en', direction=None, features=['navigation.instant', 'navigation.tabs', 'navigation.top'], palette={'primary': 'indigo', 'accent': 'indigo'}, font={'code': 'JetBrains Mono'}, icon=None, favicon='assets/spoofax.png', include_search_page=False, search_index_only=True, logo='assets/spoofax.svg') docs_dir str '/home/runner/work/spoofax-pie/spoofax-pie/docs' site_dir str '/home/runner/work/spoofax-pie/spoofax-pie/site' copyright NoneType None google_analytics NoneType None dev_addr Address Address(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/metaborg/spoofax-pie/' repo_name str 'metaborg/spoofax-pie' edit_uri str 'edit/master/docs/' extra_css list ['extra.css'] extra_javascript list [] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'] mdx_configs dict codehilite [ dict ], toc [ dict ], pymdownx.betterem [ dict ], pymdownx.emoji [ dict ], pymdownx.tasklist [ dict ] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra SubConfig {'os': {'windows': ':fontawesome-brands-windows: Windows', 'linux': ':fontawesome-brands-linux: Linux', 'macos': ':fontawesome-brands-apple: macOS'}, 'download': {'dev': {'lwb': {'eclipse': {'jvm': {'windows': ':fontawesome-brands-windows: [Windows 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-win32-x86_64-jvm&p=zip&v=LATEST)', 'macos': ':fontawesome-brands-apple: [macOS 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-macosx-x86_64-jvm&p=zip&v=LATEST)', 'linux': ':fontawesome-brands-linux: [Linux 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-linux-x86_64-jvm&p=zip&v=LATEST)'}, 'windows': ':fontawesome-brands-windows: [Windows 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-win32-x86_64&p=zip&v=LATEST)', 'macos': ':fontawesome-brands-apple: [macOS 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-macosx-x86_64&p=zip&v=LATEST)', 'linux': ':fontawesome-brands-linux: [Linux 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-linux-x86_64&p=zip&v=LATEST)'}}}}} plugins PluginCollection search [ SearchPlugin ], macros [ MacrosPlugin ], git-revision-date [ GitRevisionDatePlugin ] Git Information \u00b6 Information available on the last commit and the git repository containing the documentation project: e.g. {{ git.message }} Variable Type Content status bool True date datetime datetime.datetime(2021, 5, 27, 16, 49, 9, tzinfo=tzoffset(None, 7200)) short_commit str 'cd697bf' commit str 'cd697bf821146f90d47970bf87c8b9b92a1bae49' author str 'Gabriel Konat' tag str '' date_ISO str '2021-05-27 16:49:09 +0200' message str 'Add warning about invalid characters.' raw str 'commit cd697bf821146f90d47970bf87c8b9b92a1bae49\\nAuthor: Gabriel Konat \\nDate: Thu May 27 16:49:09 2021 +0200\\n\\n Add warning about invalid characters.' root_dir str '/home/runner/work/spoofax-pie/spoofax-pie' Page Attributes \u00b6 Provided by MkDocs. These attributes change for every page (the attributes shown are for this page). e.g. {{ page.title }} See also the MkDocs documentation on the page object . Variable Type Content file File page [ Page ], src_path = 'info.md', abs_src_path = '/home/runner/work/spoofax-pie/spoofax-pie/docs/info.md', name = 'info', dest_path = 'info/index.html', abs_dest_path = '/home/runner/work/spoofax-pie/spoofax-pie/site/info/index.html', url = 'info/' title str 'Info' parent NoneType None children NoneType None previous_page NoneType None next_page NoneType None _Page__active bool False is_section bool False is_page bool True is_link bool False update_date str '2021-05-27' canonical_url NoneType None abs_url NoneType None edit_url str 'https://github.com/metaborg/spoofax-pie/edit/master/docs/info.md' markdown str '{{ macros_info() }}\\n' content NoneType None toc list [] meta dict To have all titles of all pages, use: {% for page in navigation.pages %} - {{ page.title }} {% endfor% } Plugin Filters \u00b6 These filters are provided as a standard by the macros plugin. Variable Type Content pretty function ( var_list, rows, header, e ) Default mkdocs_macro Prettify a dictionary or object (used for environment documentation, or debugging). Builtin Jinja2 Filters \u00b6 These filters are provided by Jinja2 as a standard. See also the Jinja2 documentation on builtin filters ). Variable Type Content abs builtin_function_or_method Return the absolute value of the argument. attr function ( environment, obj, name, value ) Get an attribute of an object. foo|attr(\"bar\") works like foo.bar just that always an attribute is returned and items are not looked up. batch function ( value, linecount, fill_with, tmp, item ) A filter that batches items. It works pretty much like slice just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example. capitalize function ( s ) Capitalize a value. The first character will be uppercase, all others lowercase. center function ( value, width ) Centers the value in a field of a given width. count builtin_function_or_method Return the number of items in a container. d function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. default function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. dictsort function ( value, case_sensitive, by, reverse, sort_func ) Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. e builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. escape builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. filesizeformat function ( value, binary, bytes, base, prefixes, i, prefix, unit ) Format the value like a 'human-readable' file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to True the binary prefixes are used (Mebi, Gibi). first function ( args, kwargs, b ) Return the first item of a sequence. float function ( value, default ) Convert the value into a floating point number. If the conversion doesn't work it will return 0.0 . You can override this default using the first parameter. forceescape function ( value ) Enforce HTML escaping. This will probably double escape variables. format function ( value, args, kwargs ) Apply the given values to a printf-style _ format string, like string % values . groupby function ( args, kwargs, b ) Group a sequence of objects by an attribute using Python's :func: itertools.groupby . The attribute can use dot notation for nested access, like \"address.city\" . Unlike Python's groupby , the values are sorted first so only one group is returned for each unique value. indent function ( s, width, first, blank, newline, rv, lines ) Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default. int function ( value, default, base ) Convert the value into an integer. If the conversion doesn't work it will return 0 . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. join function ( args, kwargs, b ) Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter. last function ( environment, seq ) Return the last item of a sequence. length builtin_function_or_method Return the number of items in a container. list function ( args, kwargs, b ) Convert the value into a list. If it was a string the returned list will be a list of characters. lower function ( s ) Convert a value to lowercase. map function ( args, kwargs, b ) Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. min function ( environment, value, case_sensitive, attribute ) Return the smallest item from the sequence. max function ( environment, value, case_sensitive, attribute ) Return the largest item from the sequence. pprint function ( value ) Pretty print a variable. Useful for debugging. random function ( context, seq ) Return a random item from the sequence. reject function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. rejectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. replace function ( eval_ctx, s, old, new, count ) Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument count is given, only the first count occurrences are replaced. reverse function ( value, rv ) Reverse the object or return an iterator that iterates over it the other way round. round function ( value, precision, method, func ) Round the number to a given precision. The first parameter specifies the precision (default is 0 ), the second the rounding method. safe function ( value ) Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. select function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. selectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. slice function ( args, kwargs, b ) Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns. sort function ( environment, value, reverse, case_sensitive, attribute, key_func ) Sort an iterable using Python's :func: sorted . string builtin_function_or_method Convert an object to a string if it isn't already. This preserves a :class: Markup string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again. striptags function ( value ) Strip SGML/XML tags and replace adjacent whitespace by one space. sum function ( args, kwargs, b ) Returns the sum of a sequence of numbers plus the value of parameter 'start' (which defaults to 0). When the sequence is empty it returns start. title function ( s ) Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. trim function ( value, chars ) Strip leading and trailing characters, by default whitespace. truncate function ( env, s, length, killwords, end, leeway, result ) Return a truncated copy of the string. The length is specified with the first parameter which defaults to 255 . If the second parameter is true the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( \"...\" ). If you want a different ellipsis sign than \"...\" you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. unique function ( environment, value, case_sensitive, attribute, getter, seen, item, key ) Returns a list of unique items from the given iterable. upper function ( s ) Convert a value to uppercase. urlencode function ( value, items ) Quote data for use in a URL path or query using UTF-8. urlize function ( eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv ) Convert URLs in text into clickable links. wordcount function ( s ) Count the words in that string. wordwrap function ( environment, s, width, break_long_words, wrapstring, break_on_hyphens ) Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately. xmlattr function ( eval_ctx, d, autospace, rv ) Create an SGML/XML attribute string based on the items in a dict. All values that are neither none nor undefined are automatically escaped. tojson function ( eval_ctx, value, indent, policies, dumps, kwargs ) Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.","title":"Info"},{"location":"info/#macros-plugin-environment","text":"","title":"Macros Plugin Environment"},{"location":"info/#general-list","text":"All available variables and filters within the macros plugin: Variable Type Content extra dict os [ dict ], download [ dict ] config Config config_file_path = '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml', site_name = 'Spoofax 3', nav = [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/anatomy_language_implementation.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}], pages [ NoneType ], site_url = '', site_description = 'Spoofax 3 documentation website', site_author [ NoneType ], theme [ Theme ], docs_dir = '/home/runner/work/spoofax-pie/spoofax-pie/docs', site_dir = '/home/runner/work/spoofax-pie/spoofax-pie/site', copyright [ NoneType ], google_analytics [ NoneType ], dev_addr [ Address ], use_directory_urls = True, repo_url = 'https://github.com/metaborg/spoofax-pie/', repo_name = 'metaborg/spoofax-pie', edit_uri = 'edit/master/docs/', extra_css = ['extra.css'], extra_javascript = [], extra_templates = [], markdown_extensions = ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'], mdx_configs [ dict ], strict = False, remote_branch = 'gh-pages', remote_name = 'origin', extra [ SubConfig ], plugins [ PluginCollection ] environment dict system = 'Linux', system_version = '5.4.0-1047-azure', python_version = '3.8.10', mkdocs_version = '1.1.2', macros_plugin_version = '0.5.5', jinja2_version = '3.0.1' plugin Config module_name = 'main', modules = [], include_dir = '', include_yaml = [], j2_block_start_string = '', j2_block_end_string = '', j2_variable_start_string = '', j2_variable_end_string = '', verbose = False git dict status = True, date [ datetime ], short_commit = 'cd697bf', commit = 'cd697bf821146f90d47970bf87c8b9b92a1bae49', author = 'Gabriel Konat', tag = '', date_ISO = '2021-05-27 16:49:09 +0200', message = 'Add warning about invalid characters.', raw = 'commit cd697bf821146f90d47970bf87c8b9b92a1bae49\\nAuthor: Gabriel Konat \\nDate: Thu May 27 16:49:09 2021 +0200\\n\\n Add warning about invalid characters.', root_dir = '/home/runner/work/spoofax-pie/spoofax-pie' context function ( obj, e ) Default mkdocs_macro List the defined variables macros_info function ( ) Test/debug function: list useful documentation on the mkdocs_macro environment. now function ( ) Get the current time (returns a datetime object). Used alone, it provides a timestamp. To get the year use now().year , for the month number now().month , etc. fix_url function ( url, r ) If url is relative, fix it so that it points to the docs diretory. This is necessary because relative links in markdown must be adapted in html ('img/foo.png' => '../img/img.png'). os dict windows = ':fontawesome-brands-windows: Windows', linux = ':fontawesome-brands-linux: Linux', macos = ':fontawesome-brands-apple: macOS' download dict dev [ dict ] filters dict pretty [ function ] filters_builtin dict abs [ builtin_function_or_method ], attr [ function ], batch [ function ], capitalize [ function ], center [ function ], count [ builtin_function_or_method ], d [ function ], default [ function ], dictsort [ function ], e [ builtin_function_or_method ], escape [ builtin_function_or_method ], filesizeformat [ function ], first [ function ], float [ function ], forceescape [ function ], format [ function ], groupby [ function ], indent [ function ], int [ function ], join [ function ], last [ function ], length [ builtin_function_or_method ], list [ function ], lower [ function ], map [ function ], min [ function ], max [ function ], pprint [ function ], random [ function ], reject [ function ], rejectattr [ function ], replace [ function ], reverse [ function ], round [ function ], safe [ function ], select [ function ], selectattr [ function ], slice [ function ], sort [ function ], string [ builtin_function_or_method ], striptags [ function ], sum [ function ], title [ function ], trim [ function ], truncate [ function ], unique [ function ], upper [ function ], urlencode [ function ], urlize [ function ], wordcount [ function ], wordwrap [ function ], xmlattr [ function ], tojson [ function ] navigation Navigation Page(title='Home', url='.') Section(title='Tutorials') Page(title=[blank], url='tutorial/install/') Page(title=[blank], url='tutorial/create_language_project/') Section(title='Reference') Page(title=[blank], url='reference/anatomy_language_implementation/') Section(title='Background') Page(title=[blank], url='background/documentation/') Page(title=[blank], url='background/motivation/') Page(title=[blank], url='background/key_ideas/') Page(title=[blank], url='background/status/') Section(title='Releases') Page(title=[blank], url='release/download/') page Page Page(title='Info', url='info/')","title":"General List"},{"location":"info/#config-information","text":"Standard MkDocs configuration information. Do not try to modify. e.g. {{ config.docs_dir }} See also the MkDocs documentation on the config object . Variable Type Content config_file_path str '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml' site_name str 'Spoofax 3' nav list [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/anatomy_language_implementation.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}] pages NoneType None site_url str '' site_description str 'Spoofax 3 documentation website' site_author NoneType None theme Theme Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.8.10/x64/lib/python3.8/site-packages/material', '/opt/hostedtoolcache/Python/3.8.10/x64/lib/python3.8/site-packages/mkdocs/templates'], static_templates=['sitemap.xml', '404.html'], language='en', direction=None, features=['navigation.instant', 'navigation.tabs', 'navigation.top'], palette={'primary': 'indigo', 'accent': 'indigo'}, font={'code': 'JetBrains Mono'}, icon=None, favicon='assets/spoofax.png', include_search_page=False, search_index_only=True, logo='assets/spoofax.svg') docs_dir str '/home/runner/work/spoofax-pie/spoofax-pie/docs' site_dir str '/home/runner/work/spoofax-pie/spoofax-pie/site' copyright NoneType None google_analytics NoneType None dev_addr Address Address(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/metaborg/spoofax-pie/' repo_name str 'metaborg/spoofax-pie' edit_uri str 'edit/master/docs/' extra_css list ['extra.css'] extra_javascript list [] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'] mdx_configs dict codehilite [ dict ], toc [ dict ], pymdownx.betterem [ dict ], pymdownx.emoji [ dict ], pymdownx.tasklist [ dict ] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra SubConfig {'os': {'windows': ':fontawesome-brands-windows: Windows', 'linux': ':fontawesome-brands-linux: Linux', 'macos': ':fontawesome-brands-apple: macOS'}, 'download': {'dev': {'lwb': {'eclipse': {'jvm': {'windows': ':fontawesome-brands-windows: [Windows 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-win32-x86_64-jvm&p=zip&v=LATEST)', 'macos': ':fontawesome-brands-apple: [macOS 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-macosx-x86_64-jvm&p=zip&v=LATEST)', 'linux': ':fontawesome-brands-linux: [Linux 64-bit with embedded JVM](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-linux-x86_64-jvm&p=zip&v=LATEST)'}, 'windows': ':fontawesome-brands-windows: [Windows 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-win32-x86_64&p=zip&v=LATEST)', 'macos': ':fontawesome-brands-apple: [macOS 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-macosx-x86_64&p=zip&v=LATEST)', 'linux': ':fontawesome-brands-linux: [Linux 64-bit](https://artifacts.metaborg.org/service/local/artifact/maven/redirect?r=snapshots&g=org.metaborg&a=spoofax.lwb.eclipse.repository&c=spoofax3-linux-x86_64&p=zip&v=LATEST)'}}}}} plugins PluginCollection search [ SearchPlugin ], macros [ MacrosPlugin ], git-revision-date [ GitRevisionDatePlugin ]","title":"Config Information"},{"location":"info/#git-information","text":"Information available on the last commit and the git repository containing the documentation project: e.g. {{ git.message }} Variable Type Content status bool True date datetime datetime.datetime(2021, 5, 27, 16, 49, 9, tzinfo=tzoffset(None, 7200)) short_commit str 'cd697bf' commit str 'cd697bf821146f90d47970bf87c8b9b92a1bae49' author str 'Gabriel Konat' tag str '' date_ISO str '2021-05-27 16:49:09 +0200' message str 'Add warning about invalid characters.' raw str 'commit cd697bf821146f90d47970bf87c8b9b92a1bae49\\nAuthor: Gabriel Konat \\nDate: Thu May 27 16:49:09 2021 +0200\\n\\n Add warning about invalid characters.' root_dir str '/home/runner/work/spoofax-pie/spoofax-pie'","title":"Git Information"},{"location":"info/#page-attributes","text":"Provided by MkDocs. These attributes change for every page (the attributes shown are for this page). e.g. {{ page.title }} See also the MkDocs documentation on the page object . Variable Type Content file File page [ Page ], src_path = 'info.md', abs_src_path = '/home/runner/work/spoofax-pie/spoofax-pie/docs/info.md', name = 'info', dest_path = 'info/index.html', abs_dest_path = '/home/runner/work/spoofax-pie/spoofax-pie/site/info/index.html', url = 'info/' title str 'Info' parent NoneType None children NoneType None previous_page NoneType None next_page NoneType None _Page__active bool False is_section bool False is_page bool True is_link bool False update_date str '2021-05-27' canonical_url NoneType None abs_url NoneType None edit_url str 'https://github.com/metaborg/spoofax-pie/edit/master/docs/info.md' markdown str '{{ macros_info() }}\\n' content NoneType None toc list [] meta dict To have all titles of all pages, use: {% for page in navigation.pages %} - {{ page.title }} {% endfor% }","title":"Page Attributes"},{"location":"info/#plugin-filters","text":"These filters are provided as a standard by the macros plugin. Variable Type Content pretty function ( var_list, rows, header, e ) Default mkdocs_macro Prettify a dictionary or object (used for environment documentation, or debugging).","title":"Plugin Filters"},{"location":"info/#builtin-jinja2-filters","text":"These filters are provided by Jinja2 as a standard. See also the Jinja2 documentation on builtin filters ). Variable Type Content abs builtin_function_or_method Return the absolute value of the argument. attr function ( environment, obj, name, value ) Get an attribute of an object. foo|attr(\"bar\") works like foo.bar just that always an attribute is returned and items are not looked up. batch function ( value, linecount, fill_with, tmp, item ) A filter that batches items. It works pretty much like slice just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example. capitalize function ( s ) Capitalize a value. The first character will be uppercase, all others lowercase. center function ( value, width ) Centers the value in a field of a given width. count builtin_function_or_method Return the number of items in a container. d function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. default function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. dictsort function ( value, case_sensitive, by, reverse, sort_func ) Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. e builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. escape builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. filesizeformat function ( value, binary, bytes, base, prefixes, i, prefix, unit ) Format the value like a 'human-readable' file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to True the binary prefixes are used (Mebi, Gibi). first function ( args, kwargs, b ) Return the first item of a sequence. float function ( value, default ) Convert the value into a floating point number. If the conversion doesn't work it will return 0.0 . You can override this default using the first parameter. forceescape function ( value ) Enforce HTML escaping. This will probably double escape variables. format function ( value, args, kwargs ) Apply the given values to a printf-style _ format string, like string % values . groupby function ( args, kwargs, b ) Group a sequence of objects by an attribute using Python's :func: itertools.groupby . The attribute can use dot notation for nested access, like \"address.city\" . Unlike Python's groupby , the values are sorted first so only one group is returned for each unique value. indent function ( s, width, first, blank, newline, rv, lines ) Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default. int function ( value, default, base ) Convert the value into an integer. If the conversion doesn't work it will return 0 . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. join function ( args, kwargs, b ) Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter. last function ( environment, seq ) Return the last item of a sequence. length builtin_function_or_method Return the number of items in a container. list function ( args, kwargs, b ) Convert the value into a list. If it was a string the returned list will be a list of characters. lower function ( s ) Convert a value to lowercase. map function ( args, kwargs, b ) Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. min function ( environment, value, case_sensitive, attribute ) Return the smallest item from the sequence. max function ( environment, value, case_sensitive, attribute ) Return the largest item from the sequence. pprint function ( value ) Pretty print a variable. Useful for debugging. random function ( context, seq ) Return a random item from the sequence. reject function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. rejectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. replace function ( eval_ctx, s, old, new, count ) Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument count is given, only the first count occurrences are replaced. reverse function ( value, rv ) Reverse the object or return an iterator that iterates over it the other way round. round function ( value, precision, method, func ) Round the number to a given precision. The first parameter specifies the precision (default is 0 ), the second the rounding method. safe function ( value ) Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. select function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. selectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. slice function ( args, kwargs, b ) Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns. sort function ( environment, value, reverse, case_sensitive, attribute, key_func ) Sort an iterable using Python's :func: sorted . string builtin_function_or_method Convert an object to a string if it isn't already. This preserves a :class: Markup string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again. striptags function ( value ) Strip SGML/XML tags and replace adjacent whitespace by one space. sum function ( args, kwargs, b ) Returns the sum of a sequence of numbers plus the value of parameter 'start' (which defaults to 0). When the sequence is empty it returns start. title function ( s ) Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. trim function ( value, chars ) Strip leading and trailing characters, by default whitespace. truncate function ( env, s, length, killwords, end, leeway, result ) Return a truncated copy of the string. The length is specified with the first parameter which defaults to 255 . If the second parameter is true the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( \"...\" ). If you want a different ellipsis sign than \"...\" you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. unique function ( environment, value, case_sensitive, attribute, getter, seen, item, key ) Returns a list of unique items from the given iterable. upper function ( s ) Convert a value to uppercase. urlencode function ( value, items ) Quote data for use in a URL path or query using UTF-8. urlize function ( eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv ) Convert URLs in text into clickable links. wordcount function ( s ) Count the words in that string. wordwrap function ( environment, s, width, break_long_words, wrapstring, break_on_hyphens ) Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately. xmlattr function ( eval_ctx, d, autospace, rv ) Create an SGML/XML attribute string based on the items in a dict. All values that are neither none nor undefined are automatically escaped. tojson function ( eval_ctx, value, indent, policies, dumps, kwargs ) Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.","title":"Builtin Jinja2 Filters"},{"location":"_include/_all/","text":"","title":" all"},{"location":"_include/abbreviation/","text":"","title":"Abbreviation"},{"location":"background/documentation/","text":"Documentation \u00b6 In this section, we explain the documentation technology and how it is structured. Technology \u00b6 This documentation is developed with MkDocs , a fast and simple static site generated that's geared towards building project documentation from Markdown files. MkDocs uses Python-Markdown to process Markdown files, along with PyMdown Extensions . We use the Material for MkDocs theme which provides a clean look, easy customization, and many features for technical documentation. We use the following MkDocs plugins: mkdocs-macros-plugin to enable the use of variables, macros, and filters in Markdown files. mkdocs-git-revision-date-plugin to add a changed date to the footer based on the last time the file was changed in the Git repository. The documentation is automatically built and published on a commit to the master branch of this repository using the GitHub actions workflow at .github/workflows/documentation.yml . Structure \u00b6 The structure of this documentation follows The documentation system where documentation is split into four categories: Tutorials : oriented to learning , enabling newcomers to get started through a lesson , analogous to teaching a child how to cook . How-to guides : oriented to a particular goal , showing how to solve a specific problem through a series of steps , analogous to a recipe in a cookery book . Reference : oriented to information , describing the machinery through dry description , analogous to an encyclopaedia article . Explanation : oriented to understanding , explaining through discursive explanation , analogous to an article on culinary social history .","title":"Documentation"},{"location":"background/documentation/#documentation","text":"In this section, we explain the documentation technology and how it is structured.","title":"Documentation"},{"location":"background/documentation/#technology","text":"This documentation is developed with MkDocs , a fast and simple static site generated that's geared towards building project documentation from Markdown files. MkDocs uses Python-Markdown to process Markdown files, along with PyMdown Extensions . We use the Material for MkDocs theme which provides a clean look, easy customization, and many features for technical documentation. We use the following MkDocs plugins: mkdocs-macros-plugin to enable the use of variables, macros, and filters in Markdown files. mkdocs-git-revision-date-plugin to add a changed date to the footer based on the last time the file was changed in the Git repository. The documentation is automatically built and published on a commit to the master branch of this repository using the GitHub actions workflow at .github/workflows/documentation.yml .","title":"Technology"},{"location":"background/documentation/#structure","text":"The structure of this documentation follows The documentation system where documentation is split into four categories: Tutorials : oriented to learning , enabling newcomers to get started through a lesson , analogous to teaching a child how to cook . How-to guides : oriented to a particular goal , showing how to solve a specific problem through a series of steps , analogous to a recipe in a cookery book . Reference : oriented to information , describing the machinery through dry description , analogous to an encyclopaedia article . Explanation : oriented to understanding , explaining through discursive explanation , analogous to an article on culinary social history .","title":"Structure"},{"location":"background/key_ideas/","text":"Key ideas \u00b6 To solve the problems highlighted in the motivation section, we intend to employ the following key ideas in Spoofax 3. To reduce coupling, Spoofax 3's \"Spoofax Core\" does not depend on any meta-components. Instead, a language implementation depends directly on the meta-components that it requires. For example, the Tiger language implementation depends directly on the JSGLR2 parser, the NaBL2 constraint solver, and the Stratego runtime. To make language pipelines flexible, modular, and incremental, we use an incremental, modular, and expressive build system as the basis for creating pipelines: PIE . Language processing steps such as parsing, styling text, analyzing, checking (to provide inline error messages), running (parts of) a compiler, etc. become PIE task definitions. Tasks, which are instances of these task definitions, can depend on each other, and depend on resources such as files. The PIE runtime efficiently and incrementally executes tasks. Furthermore, task definitions can be shared and used by other language implementations, making language implementations modular. To reduce the tedium of dynamic language loading, we instead choose to do static language loading as the default. A language implementation is just a JAR file that can be put on the classpath and used as a regular Java library. For example, to use the JSGLR2 parser of the Tiger language, we just depend on the Tiger language implementation as we would depend on a regular Java library, create an instance of the TigerParser class, and then use that to parse a string into an AST. We still want to automatically provide integrations with the command-line, build systems such as Gradle, and IDEs such as Eclipse and IntelliJ. Therefore, every language implementation must implement the LanguageInstance interface. Spoofax 3 then provides libraries which take a LanguageInstance object, and integrate it with a platform. For example, spoofax.cli takes a LanguageInstance object and provides a command-line application, and spoofax.eclipse does the same for an Eclipse plugin. Because language implementations are just regular Java libraries, they now require some Java boilerplate. However, we do not want language developers to write this Java boilerplate for standard cases. Therefore, we employ a Spoofax 3 compiler that generates this Java boilerplate. If the language developer is not happy with the implementation, or wants to customize parts, they can manually implement or extend Java classes where needed. It is also possible to not use the Spoofax 3 compiler at all, and manually implement all parts. To enable quick language prototyping, we still support dynamic language loading in environments that support them (e.g., Eclipse and IntelliJ), by dynamically loading the language implementation JAR when changed. For example, when prototyping the Tiger language in Eclipse, if the syntax definition is changed we run the Spoofax 3 compiler to (incrementally) create a new parse table and Java classes, and dynamically (re)load the JAR. To improve the user experience, we use a configuration DSL to configure language specifications and implementations. Thereby configuration is centralized, has domain-specific checking, and editor services such as inline errors and code completion. We also allow changing of defaults (conventions), and persist them to enable renaming. To improve error traceability, errors are reported inline where possible. Errors are traced through PIE pipelines and support origin tracking to easily support error traceability and inline errors for all language implementations. TODO: better builders: non-Stratego commands incremental commands separate commands from how they are executed support command parameters/arguments continuous execution TODO: modular and incremental development of Spoofax 3 itself with Gradle","title":"Key ideas"},{"location":"background/key_ideas/#key-ideas","text":"To solve the problems highlighted in the motivation section, we intend to employ the following key ideas in Spoofax 3. To reduce coupling, Spoofax 3's \"Spoofax Core\" does not depend on any meta-components. Instead, a language implementation depends directly on the meta-components that it requires. For example, the Tiger language implementation depends directly on the JSGLR2 parser, the NaBL2 constraint solver, and the Stratego runtime. To make language pipelines flexible, modular, and incremental, we use an incremental, modular, and expressive build system as the basis for creating pipelines: PIE . Language processing steps such as parsing, styling text, analyzing, checking (to provide inline error messages), running (parts of) a compiler, etc. become PIE task definitions. Tasks, which are instances of these task definitions, can depend on each other, and depend on resources such as files. The PIE runtime efficiently and incrementally executes tasks. Furthermore, task definitions can be shared and used by other language implementations, making language implementations modular. To reduce the tedium of dynamic language loading, we instead choose to do static language loading as the default. A language implementation is just a JAR file that can be put on the classpath and used as a regular Java library. For example, to use the JSGLR2 parser of the Tiger language, we just depend on the Tiger language implementation as we would depend on a regular Java library, create an instance of the TigerParser class, and then use that to parse a string into an AST. We still want to automatically provide integrations with the command-line, build systems such as Gradle, and IDEs such as Eclipse and IntelliJ. Therefore, every language implementation must implement the LanguageInstance interface. Spoofax 3 then provides libraries which take a LanguageInstance object, and integrate it with a platform. For example, spoofax.cli takes a LanguageInstance object and provides a command-line application, and spoofax.eclipse does the same for an Eclipse plugin. Because language implementations are just regular Java libraries, they now require some Java boilerplate. However, we do not want language developers to write this Java boilerplate for standard cases. Therefore, we employ a Spoofax 3 compiler that generates this Java boilerplate. If the language developer is not happy with the implementation, or wants to customize parts, they can manually implement or extend Java classes where needed. It is also possible to not use the Spoofax 3 compiler at all, and manually implement all parts. To enable quick language prototyping, we still support dynamic language loading in environments that support them (e.g., Eclipse and IntelliJ), by dynamically loading the language implementation JAR when changed. For example, when prototyping the Tiger language in Eclipse, if the syntax definition is changed we run the Spoofax 3 compiler to (incrementally) create a new parse table and Java classes, and dynamically (re)load the JAR. To improve the user experience, we use a configuration DSL to configure language specifications and implementations. Thereby configuration is centralized, has domain-specific checking, and editor services such as inline errors and code completion. We also allow changing of defaults (conventions), and persist them to enable renaming. To improve error traceability, errors are reported inline where possible. Errors are traced through PIE pipelines and support origin tracking to easily support error traceability and inline errors for all language implementations. TODO: better builders: non-Stratego commands incremental commands separate commands from how they are executed support command parameters/arguments continuous execution TODO: modular and incremental development of Spoofax 3 itself with Gradle","title":"Key ideas"},{"location":"background/motivation/","text":"Motivation \u00b6 In this section we discuss the motivations for developing Spoofax 3. Architecture \u00b6 The main motivation for developing Spoofax 3 is the monolithic, inflexible, and non-incremental architecture of Spoofax 2: It has an inflexible fixed-function pipeline , where every file of your language is parsed, analyzed, and transformed. This works fine, and can even be incremental when the files of your language can be separately compiled. However, this is often not the case. Languages should be able to define their own incremental pipelines with minimal effort. Those pipelines should be modular and flexible, enabling usage in a wide range applications such as command-line interfaces, build systems, code editors, and IDEs. It is monolithic for language users (i.e., the users of your programming language that you have developed with Spoofax), as every language developed with Spoofax 2 depends on Spoofax Core, which in turn depends on all meta-components: JSGLR1 and 2, NaBL+TS index and task engine, NaBL2 & Statix solver, dynsem interpreter, Stratego runtime, config parsing libraries, etc. A language should only require the meta-components that it uses. It is monolithic for meta-component developers (e.g., the developers of the language workbench, or researchers experimenting with new meta-tools or meta-languages). New meta-components need to be tightly integrated into Spoofax Core, requiring time-consuming changes and introducing increased coupling. We should develop meta-components in separation, and loosely couple/integrate them (as much as possible). The build of Spoofax 2 itself is monolithic and non-incremental, as all its components are compiled in one huge non-incremental build, massively increasing iteration time during development. The build must be incremental, and components should be separated where possible to reduce coupling, decreasing iteration times. Language loading \u00b6 Furthermore, Spoofax 2 only support dynamic loading of languages , where a language can be (re)loaded into the running environment. This is very useful during language development, as it enables fast prototyping. However, when we want to statically load the language, we still need to perform the dynamic loading ritual: somehow include the language archive in your application, and then load it at runtime. This hurts startup time, is not supported on some platforms (e.g., Graal native image), and is tedious. We should support both static and dynamic loading (where possible). Error tracing \u00b6 Some errors are not being traced back to their source. For example, many errors in configuration only show up during build time (in the console, which may be hidden) and are not traced back to the configuration file. This confuses users, and may get stuck on simple things, which then require help from us. Errors, warnings, and informational messages should be traced back to their source, and shown inline at the source in IDE environments, or shown as a list of messages with origin information on the command-line. When there are errors, execution should continue in certain instances (e.g., parse error should recover and try to do analysis), but should not in others (e.g., error from static analysis should prevent execution since it could crash). Configuration \u00b6 Another issue is the scattered configuration in language specifications, which is spread over many different places: metaborg.yaml editor/*.esv dynsem.properties In meta-languages files. For example, template options in SDF3. pom.xml .mvn/extensions.xml Finding the right configuration option in these files, and keeping them in sync, is tedious. Furthermore, while most configuration is documented on our website, looking that up still causes a cognitive gap. We should consolidate configuration that belongs together, and not have any duplicate configuration that needs to be kept in sync. Configuration should be supported with editor services such as inline errors and code completion, if possible. Moreover, some parts of a language specification are configured by convention, and these conventions cannot be changed. For example, the main SDF3 file is always assumed to be syntax/<language-name>.sdf3 . When the language name is changed, but we forget to change the name of this main file, no parse table is built. Configuration conventions should be changeable, and defaults should be persisted to ensure that renamings do not break things. Summary of Problems \u00b6 To summarize, Spoofax 2 suffers from the following problems that form the motivation for Spoofax 3: Monolithic, inflexible, and non-incremental architecture causing: Inflexible and slow language processing due to non-incremental fixed-function pipeline Coupling in Spoofax Core: every language depends on Spoofax Core, and Spoofax Core depends on all meta-components Slow iteration times when developing Spoofax 2 due to its monolithic and non-incremental build Tedious to use languages due to dynamic language loading Confusing (end-)user experience due to: Bad error traceability Scattered configuration Non-incremental configuration (restarts required to update configuration)","title":"Motivation"},{"location":"background/motivation/#motivation","text":"In this section we discuss the motivations for developing Spoofax 3.","title":"Motivation"},{"location":"background/motivation/#architecture","text":"The main motivation for developing Spoofax 3 is the monolithic, inflexible, and non-incremental architecture of Spoofax 2: It has an inflexible fixed-function pipeline , where every file of your language is parsed, analyzed, and transformed. This works fine, and can even be incremental when the files of your language can be separately compiled. However, this is often not the case. Languages should be able to define their own incremental pipelines with minimal effort. Those pipelines should be modular and flexible, enabling usage in a wide range applications such as command-line interfaces, build systems, code editors, and IDEs. It is monolithic for language users (i.e., the users of your programming language that you have developed with Spoofax), as every language developed with Spoofax 2 depends on Spoofax Core, which in turn depends on all meta-components: JSGLR1 and 2, NaBL+TS index and task engine, NaBL2 & Statix solver, dynsem interpreter, Stratego runtime, config parsing libraries, etc. A language should only require the meta-components that it uses. It is monolithic for meta-component developers (e.g., the developers of the language workbench, or researchers experimenting with new meta-tools or meta-languages). New meta-components need to be tightly integrated into Spoofax Core, requiring time-consuming changes and introducing increased coupling. We should develop meta-components in separation, and loosely couple/integrate them (as much as possible). The build of Spoofax 2 itself is monolithic and non-incremental, as all its components are compiled in one huge non-incremental build, massively increasing iteration time during development. The build must be incremental, and components should be separated where possible to reduce coupling, decreasing iteration times.","title":"Architecture"},{"location":"background/motivation/#language-loading","text":"Furthermore, Spoofax 2 only support dynamic loading of languages , where a language can be (re)loaded into the running environment. This is very useful during language development, as it enables fast prototyping. However, when we want to statically load the language, we still need to perform the dynamic loading ritual: somehow include the language archive in your application, and then load it at runtime. This hurts startup time, is not supported on some platforms (e.g., Graal native image), and is tedious. We should support both static and dynamic loading (where possible).","title":"Language loading"},{"location":"background/motivation/#error-tracing","text":"Some errors are not being traced back to their source. For example, many errors in configuration only show up during build time (in the console, which may be hidden) and are not traced back to the configuration file. This confuses users, and may get stuck on simple things, which then require help from us. Errors, warnings, and informational messages should be traced back to their source, and shown inline at the source in IDE environments, or shown as a list of messages with origin information on the command-line. When there are errors, execution should continue in certain instances (e.g., parse error should recover and try to do analysis), but should not in others (e.g., error from static analysis should prevent execution since it could crash).","title":"Error tracing"},{"location":"background/motivation/#configuration","text":"Another issue is the scattered configuration in language specifications, which is spread over many different places: metaborg.yaml editor/*.esv dynsem.properties In meta-languages files. For example, template options in SDF3. pom.xml .mvn/extensions.xml Finding the right configuration option in these files, and keeping them in sync, is tedious. Furthermore, while most configuration is documented on our website, looking that up still causes a cognitive gap. We should consolidate configuration that belongs together, and not have any duplicate configuration that needs to be kept in sync. Configuration should be supported with editor services such as inline errors and code completion, if possible. Moreover, some parts of a language specification are configured by convention, and these conventions cannot be changed. For example, the main SDF3 file is always assumed to be syntax/<language-name>.sdf3 . When the language name is changed, but we forget to change the name of this main file, no parse table is built. Configuration conventions should be changeable, and defaults should be persisted to ensure that renamings do not break things.","title":"Configuration"},{"location":"background/motivation/#summary-of-problems","text":"To summarize, Spoofax 2 suffers from the following problems that form the motivation for Spoofax 3: Monolithic, inflexible, and non-incremental architecture causing: Inflexible and slow language processing due to non-incremental fixed-function pipeline Coupling in Spoofax Core: every language depends on Spoofax Core, and Spoofax Core depends on all meta-components Slow iteration times when developing Spoofax 2 due to its monolithic and non-incremental build Tedious to use languages due to dynamic language loading Confusing (end-)user experience due to: Bad error traceability Scattered configuration Non-incremental configuration (restarts required to update configuration)","title":"Summary of Problems"},{"location":"background/status/","text":"Current Status \u00b6 We have stated our key ideas, but since Spoofax 3 is still under heavy development, they have not all been implemented yet. We now discuss the current status of Spoofax 3 by summarizing the key ideas and whether they has been implemented, along with any comments. Decoupling : Spoofax Core not depend on any meta-components. Language implementations instead depend on the meta-components they require. Flexible, modular and incremental pipelines : Use PIE . Static loading : Use static loading by default, making language implementation plain JAR files, which are easy to use in the Java ecosystem. LanguageInstance interface : Language implementations must implement the LanguageInstance interface, which a platform library uses to integrate a language with the platform. An initial version of the LanguageInstance interface exists, but this interface is not yet stable and will receive many new features. Currently, this interface contains features pertaining both command-line platforms and IDE/code editor platforms. These may be split up in the future. Generate Java boilerplate : Generate the Java boilerplate that Spoofax 3 now requires due to the LanguageInstance interface and language implementations being plain JAR files. Configuration for the Spoofax 3 compiler is provided through a Gradle build script, which is verbose. Quick language prototyping : Support dynamic language loading in environments that support this, to enable quick language prototyping. Configuration DSL : Use a configuration DSL to improve the developer/user experience. Error origin tracking : Perform origin tracking and propagation on errors to improve the developer/user experience. Errors are traced through most PIE tasks, but do not always contain specific origin information Commands : More flexible and incremental version of \"builders\" from Spoofax 2. Non-Stratego commands : Commands execute PIE tasks, which execute Java code. Incremental commands : Commands are incremental because they execute PIE tasks. Separate commands from how they are executed : Commands can be bound to IDE/editor menus, command-line commands, or to resource changes. Command parameters/arguments : Commands can specify parameters, which must be provided as arguments when executed. Modular and incremental development : Use Gradle (instead of Maven) to build Spoofax 3, which increases modularity and provides incremental builds for faster iteration times. Furthermore, we now discuss the status of features that were not new key ideas. Language builds We have an initial version of a Spoofax 3 compiler which is completely based on Spoofax 3 and PIE (independent from Spoofax 2), but it is still unstable. Meta-language bootstrapping Bootstrapping requires implementation of the meta-languages in Spoofax 3, which we have not done yet. Meta-tools Syntax specification SDF3 Parsing JSGLR1 JSGLR2 Incremental parsing New water rules Styling specification ESV (syntax-based) Semantic analysis NaBL2 Statix Statix signature generation based on SDF3 specification FlowSpec Stratego Transformation (compilation) Stratego Editor services Syntax-based styling Inline error/warning/note messages Code completion Outline Platforms Command-line Eclipse An Eclipse plugin for your language is provided, but it not yet mature Concurrency/parallelism is completely ignored. Therefore, things may run concurrently that are not suppose to which cause data races and crashes. IntelliJ A very minimal IntelliJ plugin for your language is provided, currently only supporting syntax highlighting and inline parse errors. Gradle Maven REPL The following features are being prototyped/experimented with Spoofax 3: Multi-lingual semantic analysis with Statix (Aron Zwaan) Semantic code completion based on Statix specification (Daniel Pelsmaeker) The following features will most likely not be supported: Analysis with NaBL/TS","title":"Current Status"},{"location":"background/status/#current-status","text":"We have stated our key ideas, but since Spoofax 3 is still under heavy development, they have not all been implemented yet. We now discuss the current status of Spoofax 3 by summarizing the key ideas and whether they has been implemented, along with any comments. Decoupling : Spoofax Core not depend on any meta-components. Language implementations instead depend on the meta-components they require. Flexible, modular and incremental pipelines : Use PIE . Static loading : Use static loading by default, making language implementation plain JAR files, which are easy to use in the Java ecosystem. LanguageInstance interface : Language implementations must implement the LanguageInstance interface, which a platform library uses to integrate a language with the platform. An initial version of the LanguageInstance interface exists, but this interface is not yet stable and will receive many new features. Currently, this interface contains features pertaining both command-line platforms and IDE/code editor platforms. These may be split up in the future. Generate Java boilerplate : Generate the Java boilerplate that Spoofax 3 now requires due to the LanguageInstance interface and language implementations being plain JAR files. Configuration for the Spoofax 3 compiler is provided through a Gradle build script, which is verbose. Quick language prototyping : Support dynamic language loading in environments that support this, to enable quick language prototyping. Configuration DSL : Use a configuration DSL to improve the developer/user experience. Error origin tracking : Perform origin tracking and propagation on errors to improve the developer/user experience. Errors are traced through most PIE tasks, but do not always contain specific origin information Commands : More flexible and incremental version of \"builders\" from Spoofax 2. Non-Stratego commands : Commands execute PIE tasks, which execute Java code. Incremental commands : Commands are incremental because they execute PIE tasks. Separate commands from how they are executed : Commands can be bound to IDE/editor menus, command-line commands, or to resource changes. Command parameters/arguments : Commands can specify parameters, which must be provided as arguments when executed. Modular and incremental development : Use Gradle (instead of Maven) to build Spoofax 3, which increases modularity and provides incremental builds for faster iteration times. Furthermore, we now discuss the status of features that were not new key ideas. Language builds We have an initial version of a Spoofax 3 compiler which is completely based on Spoofax 3 and PIE (independent from Spoofax 2), but it is still unstable. Meta-language bootstrapping Bootstrapping requires implementation of the meta-languages in Spoofax 3, which we have not done yet. Meta-tools Syntax specification SDF3 Parsing JSGLR1 JSGLR2 Incremental parsing New water rules Styling specification ESV (syntax-based) Semantic analysis NaBL2 Statix Statix signature generation based on SDF3 specification FlowSpec Stratego Transformation (compilation) Stratego Editor services Syntax-based styling Inline error/warning/note messages Code completion Outline Platforms Command-line Eclipse An Eclipse plugin for your language is provided, but it not yet mature Concurrency/parallelism is completely ignored. Therefore, things may run concurrently that are not suppose to which cause data races and crashes. IntelliJ A very minimal IntelliJ plugin for your language is provided, currently only supporting syntax highlighting and inline parse errors. Gradle Maven REPL The following features are being prototyped/experimented with Spoofax 3: Multi-lingual semantic analysis with Statix (Aron Zwaan) Semantic code completion based on Statix specification (Daniel Pelsmaeker) The following features will most likely not be supported: Analysis with NaBL/TS","title":"Current Status"},{"location":"reference/anatomy_language_implementation/","text":"Anatomy of a language implementation \u00b6 In this section we give a high-level overview of what a Spoofax 3 language implementation is, dive into details, and explain how such a implementation can be manually written or completely generated from a high-level language specification Overview \u00b6 In essence, a language implementation in Spoofax 3 is nothing more than a standard Java library (e.g., a JAR file) with Java classes implementing or delegating to the various functionalities of the language such as parsing and transformations, as well as bundled resources such as a parse table which is loaded and interpreted at runtime. Therefore, Spoofax 3 language implementations are very easy to use in the Java ecosystem by just distributing the JAR file of the language, or by publishing/consuming it as a library with a build system such as Gradle. Furthermore, since no classloading or class generation is used, GraalVM native image can be used to ahead-of-time compile your language implementation into native code which does not require a JVM at all, and significantly reduces the startup time of your language. Diving deeper, a language implementation is actually split into three parts: a language project that contains the base functionality of the language, an adapter project that adapts the language project to the interface of Spoofax, and platform projects that plug the adapter project into various other platforms such as a command-line interface (CLI) and Eclipse plugin (TODO: more details on supported platforms in a separate section). We will first explain these projects and why this separation was chosen. TODO: diagram? Language Project \u00b6 A language project contains the base functionality of a language, such as a parser, syntax highlighter, analyzer, and compiler for the language. Such a project is unstructured : it does not have to adhere to any interface or data format. Therefore, it may use any tooling, libraries, and data structures to implement the base functionality. This facilitates integration of existing tools and minimal dependencies. A language project is just a Java library and can thus be used in a standalone fashion. However, there is no glue between base functionality, requiring manual implementation of a parse-analyze-compile pipeline for example. Furthermore, because the project is unstructured, we cannot provide any integration with other platforms such as a CLI and Eclipse plugin. Therefore, using a language project as a standalone library is a bit of a niche use case for when minimal dependencies or full control is absolutely necessary. Because it is such a niche use case, the default in Spoofax 3 is to merge it together with the adapter project. In essence, an adapter project adapts a language project to Spoofax 3. To understand why, we first explain the high-level architecture of Spoofax 3. Spoofax 3 architecture overview \u00b6 Spoofax 3 provides a general interface for language implementations: LanguageInstance , which is used by platforms to automatically plug languages into their platform. For example, LanguageInstance has functionality for syntax highlighting , which when given a resource of the language, returns a syntax highlighting for that resource. (TODO: more details on the functionality in LanguageInstance in a separate section) Furthermore, Spoofax 3 uses PIE ; a framework for building incremental pipelines, build systems, and compilers; to incrementalize the language implementation. Instead of directly computing the syntax highlighting for a resource, we create a task that returns the syntax highlighting when demanded, with PIE taking care of whether it should recompute the syntax highlighting because the resource (or the syntax highlighting implementation) changed, or if it can just be returned from a cache. (TODO: more details on PIE in a separate section) A platform such as Eclipse or IntelliJ can then take a LanguageInstance implementation, demand the syntax highlighting task, and show the result it in the editor for your language. Therefore, any language that implements LanguageInstance can get syntax highlighting in Eclipse, IntelliJ, and any other supported platforms for free, with PIE taking care of coarse-grained incrementalization. To receive the benefits of Spoofax 3, the adapter project must thus be implemented for your language. Adapter Project \u00b6 An adapter project implements Spoofax 3's LanguageInstance using the language project. This requires glue code between the unstructured language project and the structured LanguageInstance interface. For example, you would need to convert the data structure that the syntax highlighter of your language returns, to one that Spoofax 3 understands: the Styling class. Furthermore, because Spoofax 3 uses PIE, we also need to implement a PIE task definition that implements the (re)computing of syntax highlighting, as well as mark all dependencies that should cause the syntax highlighting to be recomputed. We also need to be able to instantiate your implementation of LanguageInstance . In case this is non-trivial, the recommended practice is to use dependency injection to achieve proper separation of concerns. A dependency injection framework such as Dagger is recommended (we use it extensively in Spoofax 3) because it catches dependency injection errors at compile-time, and does not require runtime class loading or generation. This may sound like you would need to write a lot of boilerplate. However, we provide a compiler that generates all this boilerplate for you. It is only necessary to write this boilerplate if you are integrating existing tooling. Even then, the compiler can generate some of the boilerplate for you. More details on the compiler can be found in the developing language implementations section. Platform Projects \u00b6 TODO: every language-platform combination is a separate project to support ahead-of-time compilation, static loading, and customization of the platform project. CLI: can be ahead-of-time compiled with GraalVM native image to create a native Windows/macOS/Linux CLI for your language Eclipse/IntelliJ: statically loaded plugin that can be deployed with Eclipse/IntelliJ, and can be fully customized. Developing Language Implementations \u00b6 So far we have talked about what a language implementation is, but not yet how one is developed, which we will dive into now. Language implementations are by default fully generated from a high-level language specification using the Spoofax 3 compiler, thereby supporting iterative language development with low boilerplate. However, it is possible implement parts of or even the entire language/adapter project by hand, facilitating the integration of existing tools and languages. TODO: dynamic loading","title":"Anatomy of a language implementation"},{"location":"reference/anatomy_language_implementation/#anatomy-of-a-language-implementation","text":"In this section we give a high-level overview of what a Spoofax 3 language implementation is, dive into details, and explain how such a implementation can be manually written or completely generated from a high-level language specification","title":"Anatomy of a language implementation"},{"location":"reference/anatomy_language_implementation/#overview","text":"In essence, a language implementation in Spoofax 3 is nothing more than a standard Java library (e.g., a JAR file) with Java classes implementing or delegating to the various functionalities of the language such as parsing and transformations, as well as bundled resources such as a parse table which is loaded and interpreted at runtime. Therefore, Spoofax 3 language implementations are very easy to use in the Java ecosystem by just distributing the JAR file of the language, or by publishing/consuming it as a library with a build system such as Gradle. Furthermore, since no classloading or class generation is used, GraalVM native image can be used to ahead-of-time compile your language implementation into native code which does not require a JVM at all, and significantly reduces the startup time of your language. Diving deeper, a language implementation is actually split into three parts: a language project that contains the base functionality of the language, an adapter project that adapts the language project to the interface of Spoofax, and platform projects that plug the adapter project into various other platforms such as a command-line interface (CLI) and Eclipse plugin (TODO: more details on supported platforms in a separate section). We will first explain these projects and why this separation was chosen. TODO: diagram?","title":"Overview"},{"location":"reference/anatomy_language_implementation/#language-project","text":"A language project contains the base functionality of a language, such as a parser, syntax highlighter, analyzer, and compiler for the language. Such a project is unstructured : it does not have to adhere to any interface or data format. Therefore, it may use any tooling, libraries, and data structures to implement the base functionality. This facilitates integration of existing tools and minimal dependencies. A language project is just a Java library and can thus be used in a standalone fashion. However, there is no glue between base functionality, requiring manual implementation of a parse-analyze-compile pipeline for example. Furthermore, because the project is unstructured, we cannot provide any integration with other platforms such as a CLI and Eclipse plugin. Therefore, using a language project as a standalone library is a bit of a niche use case for when minimal dependencies or full control is absolutely necessary. Because it is such a niche use case, the default in Spoofax 3 is to merge it together with the adapter project. In essence, an adapter project adapts a language project to Spoofax 3. To understand why, we first explain the high-level architecture of Spoofax 3.","title":"Language Project"},{"location":"reference/anatomy_language_implementation/#spoofax-3-architecture-overview","text":"Spoofax 3 provides a general interface for language implementations: LanguageInstance , which is used by platforms to automatically plug languages into their platform. For example, LanguageInstance has functionality for syntax highlighting , which when given a resource of the language, returns a syntax highlighting for that resource. (TODO: more details on the functionality in LanguageInstance in a separate section) Furthermore, Spoofax 3 uses PIE ; a framework for building incremental pipelines, build systems, and compilers; to incrementalize the language implementation. Instead of directly computing the syntax highlighting for a resource, we create a task that returns the syntax highlighting when demanded, with PIE taking care of whether it should recompute the syntax highlighting because the resource (or the syntax highlighting implementation) changed, or if it can just be returned from a cache. (TODO: more details on PIE in a separate section) A platform such as Eclipse or IntelliJ can then take a LanguageInstance implementation, demand the syntax highlighting task, and show the result it in the editor for your language. Therefore, any language that implements LanguageInstance can get syntax highlighting in Eclipse, IntelliJ, and any other supported platforms for free, with PIE taking care of coarse-grained incrementalization. To receive the benefits of Spoofax 3, the adapter project must thus be implemented for your language.","title":"Spoofax 3 architecture overview"},{"location":"reference/anatomy_language_implementation/#adapter-project","text":"An adapter project implements Spoofax 3's LanguageInstance using the language project. This requires glue code between the unstructured language project and the structured LanguageInstance interface. For example, you would need to convert the data structure that the syntax highlighter of your language returns, to one that Spoofax 3 understands: the Styling class. Furthermore, because Spoofax 3 uses PIE, we also need to implement a PIE task definition that implements the (re)computing of syntax highlighting, as well as mark all dependencies that should cause the syntax highlighting to be recomputed. We also need to be able to instantiate your implementation of LanguageInstance . In case this is non-trivial, the recommended practice is to use dependency injection to achieve proper separation of concerns. A dependency injection framework such as Dagger is recommended (we use it extensively in Spoofax 3) because it catches dependency injection errors at compile-time, and does not require runtime class loading or generation. This may sound like you would need to write a lot of boilerplate. However, we provide a compiler that generates all this boilerplate for you. It is only necessary to write this boilerplate if you are integrating existing tooling. Even then, the compiler can generate some of the boilerplate for you. More details on the compiler can be found in the developing language implementations section.","title":"Adapter Project"},{"location":"reference/anatomy_language_implementation/#platform-projects","text":"TODO: every language-platform combination is a separate project to support ahead-of-time compilation, static loading, and customization of the platform project. CLI: can be ahead-of-time compiled with GraalVM native image to create a native Windows/macOS/Linux CLI for your language Eclipse/IntelliJ: statically loaded plugin that can be deployed with Eclipse/IntelliJ, and can be fully customized.","title":"Platform Projects"},{"location":"reference/anatomy_language_implementation/#developing-language-implementations","text":"So far we have talked about what a language implementation is, but not yet how one is developed, which we will dive into now. Language implementations are by default fully generated from a high-level language specification using the Spoofax 3 compiler, thereby supporting iterative language development with low boilerplate. However, it is possible implement parts of or even the entire language/adapter project by hand, facilitating the integration of existing tools and languages. TODO: dynamic loading","title":"Developing Language Implementations"},{"location":"release/download/","text":"Downloads \u00b6 This page contains download links to for the latest development version of Spoofax 3. Eclipse Language Workbench Environment \u00b6 With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Downloads"},{"location":"release/download/#downloads","text":"This page contains download links to for the latest development version of Spoofax 3.","title":"Downloads"},{"location":"release/download/#eclipse-language-workbench-environment","text":"With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Eclipse Language Workbench Environment"},{"location":"tutorial/create_language_project/","text":"Creating a language project \u00b6 This tutorial gets you started with language development by creating a language project and changing various aspects of the language. First follow the installation tutorial if you haven't done so yet. Creating a new project \u00b6 In Eclipse, open the new project dialog by choosing File \u2023 New \u2023 Project from the main menu. In the new project dialog, select Spoofax LWB \u2023 Spoofax language project and press Next . In this wizard, you can customize the various names your language will use. However, for the purpose of this tutorial, fill in HelloWorld as the name of the project, which will automatically fill in the other elements with defaults. Then press Finish to create the project. There should now be a project named helloworld in the Package Explorer . Adding syntax \u00b6 First we will add some syntax to the language. Open the main SDF3 file helloworld/src/start.sdf3 file by expanding the folders and double-clicking the file. SDF3 is a meta-language (i.e., a language to describe languages) for describing the syntax of a language, from which Spoofax will derive the parser of your language. Under the context-free syntax section, replace the Start . Empty = <> line with Start . Program = <<{ Part \" \" } * >> , indicating that the language accepts programs which consists of one or more parts. Then add Part . Hello = < hello > on a new line, indicating that one sort of part is the word hello. Finally, add Part . World = < world > on a new line, indicating that one sort of part is the word world . The context-free syntax section should now look as follows: context-free syntax Start . Program = <<{ Part \" \" } * >> Part . Hello = < hello > Part . World = < world > To test our change, build the project by clicking on the project in the Package Explorer and choosing Project \u2023 Build Project from the main menu, or by pressing Cmd + B on macOS or Ctrl + B on others. To see when the build is done, open the progress window by choosing Window \u2023 Show View \u2023 Progress . If the progress view is empty, the build is done. The initial build can be a bit slow because there is a lot of code to compile in the background. Subsequent builds will be faster due to incrementalization. Create a test file for your language by right-clicking the project and choosing New \u2023 File , filling in test.hel as file name, and pressing Finish . Type a valid sentence such as hello world hello hello world in this file, and it will highlight purple indicating that hello and world are keywords. There will also be an error marker on the file because we have not yet updated the static semantics (i.e., type checker) of the language to handle the language constructs we just added. That is ok for now, we will fix this later. Changing syntax highlighting \u00b6 Now we will change the syntax highlighter of the language. Open the main ESV file helloworld/src/main.esv . ESV is a meta-language for describing the syntax highlighter. Change the keyword : 127 0 85 bold line to keyword : 0 0 150 bold and build the project. Then check your test.hel example file, it should now be highlighted blue. To make iteration easier, you can drag the test.hel tab to the side of the screen to open the language definition and example file side-by-side. You can play around with the coloring a bit and choose a style to your liking. Remember to rebuild the project after making a change to the language definition. Adding a debugging command \u00b6 It can be quite handy to look at the AST of a program that the parser of the language produces as a debugging tool. To do that, we will write a task definition that produces the AST of a program by parsing it, we will add a command definition for that task, and finally we will bind the command to a menu item so that we can execute the command. Creating the task definition \u00b6 A task definition is a piece of code that take some input, may read from or write to files, run and get the result of other tasks, and produce some output. Task definitions come from PIE , a framework for developing composable, incremental, correct, and expressive pipelines and build scripts. All user interaction, pipelines, and builds in Spoofax 3 are composed of task definitions. So whenever you want to perform a command, present feedback to the user, or compile your language, you will need to write a task definition for it. For brevity, we usually just refer to a \"task definition\" by \"task\". For PIE to be able to incrementally execute your task, you must make your dependencies explicit. That is, dependencies to files and other tasks must be made explicit. However, because PIE supports dynamic dependencies , those dependencies are made while the build script is executing . A full tutorial on PIE is outside the scope of this tutorial, but we will implement several tasks in this tutorial, explain the PIE concepts, and how Spoofax 3 uses these concepts. A task definition is written as a class in Java, and needs to adhere to a certain interface. Let's start by creating the class for this task. First, right-click the helloworld/src/main/java directory and choose New \u2023 Package , replace the name with mb.helloworld.task , and press Finish . Then, right-click the mb.helloworld.task package we just created and choose New \u2023 Class and fill in HelloWorldShowParsedAst as name, then press Finish . Replace the entire Java file with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import org.spoofax.interpreter.terms.IStrategoTerm ; import mb.common.result.Result ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.jsglr1.common.JSGLR1ParseException ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.stratego.common.StrategoUtil ; @HelloWorldScope // (10) public class HelloWorldShowParsedAst implements TaskDef < HelloWorldShowParsedAst . Args , CommandFeedback > { // (1) public static class Args implements Serializable { // (2) private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { // (3) context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); // (4) final ResourceKey file = args . file ; final Result < IStrategoTerm , JSGLR1ParseException > astResult = context . require ( parse . inputBuilder (). withFile ( file ). buildAstSupplier ()); // (5) return astResult . mapOrElse ( // (6) ast -> CommandFeedback . of ( ShowFeedback . showText ( StrategoUtil . toString ( ast ), \"Parsed AST for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { // (7) return getClass (). getName (); } // (8) private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; @Inject // (9) public HelloWorldShowParsedAst ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse ) { this . classloaderResources = classloaderResources ; this . parse = parse ; } } We explain this class with numbered annotations in the above Java source file: This class implements TaskDef , which is an interface from PIE which a class must implement to be a task definition. Task definitions have an input and output type defined by the first and second generic argument. To execute this task, an object of the input type is required, and once it is done executing, it must return an object of the output type. In this concrete case, the input type is HelloWorldShowParsedAst . Args which is a nested data class defined at (2). The output is CommandFeedback which is a type defined by Spoofax for providing feedback back to the user when executing a command. All tasks that are executed through commands must return a CommandFeedback object. A nested data class encapsulating the input to this task. In this case, we want this task to take the file we are going to show the AST of as input. Even though we only take one argument as input, we must encapsulate it in a class due to the way commands in Spoofax work. This data class must implement Serializable because it is used as an input to a task. In order for PIE to incrementalize tasks across JVM restarts, it must be able to serialize the input (and output) objects to disk. Furthermore, this class must be immutable, because PIE caches input (and output) objects, and this caching would be inconsistent if the class is mutable. This class is immutable by storing the file in a final field which is set in the constructor (and the ResourceKey class is immutable as well). Spoofax and PIE abstract over files with resources . A resource is some externally managed mutable state, with a (immutable and serializable) key which can be used to identify, read, and write to that resource. Such a key is represented by a ResourceKey . Finally, this data class must implement equals and hashCode according to the data in the class because PIE uses these methods to identify tasks according to their input, which in turn is used for caching. A toString implementation is also recommended for debugging. The exec method which is called when the task is executed. It takes an ExecContext as input, which is used to tell PIE about dependencies to files, and can be used to execute and get the result of another task (implicitly creating a dependency to that task). It also takes the input type Args as input, and must return a CommandFeedback . For sound incrementality, we want to re-execute this task when we make changes to this class. Therefore, we want to make a self-dependency . That is, we want to make a file dependency to the Java class file that is compiled from this Java source file. The classloaderResources object (defined below at (8)) is used to get the class or JAR file of the current class. This resource is passed to context . require to tell PIE that this task depends on that file. We pass in ResourceStampers . hashFile () as the second argument, which indicates that we want to use the hash of the class file to detect changes, instead of the last modified date which is used by default. It is recommended to use hashes for dependencies to generated/compiled files, as compiled files are sometimes recompiled without changes, which changes the modified date but not the hash, leading to better incrementality. To show the AST we must parse the input file, and in order to do that we must call a task which performs the parsing. Whereas (4) uses context . require to create a dependency to a file , we use context . require here to create a dependency to the task that does the parsing, and get the output of that task. As input to context . require we pass parse . inputBuilder (). withFile ( file ). buildAstSupplier () , which uses the builder pattern to create an input for the parse task and then extracts the AST from the output. Internally, the parse task creates a dependency to the file we pass into it. We depend on the parse task. Therefore, when the file changes, PIE re-executes the parse task, and then re-executes this task if the output of the parse task is different. Thereby, PIE incrementally executes your task without having to incrementalize it yourself. The output of the parse task is Result < IStrategoTerm , JSGLR1ParseException > which is a result type which is either a IStrategoTerm representing the AST of the file if parsing succeeds, or a JSGLR1ParseException when parsing fails. Instead of throwing exceptions, we use result types (akin to Either in Haskell or Result in Rust) to model the possibility of failure with values. We do this to make it possible to work with failures in PIE tasks. In PIE, throwing an exception signifies an unrecoverable error and cancels the entire pipeline. However, using failures as values works normally. Now that we have the result of parsing, we can turn it into a CommandFeedback object. We use mapOrElse of Result to map the result to a CommandFeedback differently depending on whether parsing succeeded or failed. If parsing succeeded, we show the AST as text to the user with CommandFeedback . of ( ShowFeedback . showText (...)) with the first argument providing the text, and the second argument providing the title. The IDE then shows this as a textual editor. If parsing failed, we present the parse error messages as feedback to the user with CommandFeedback . ofTryExtractMessagesFrom . Finally, PIE needs to be able to identify this task definition. That is done by this getId method that returns a unique identifier. This can almost always be implemented using getClass (). getName () which returns the fully qualified name of this class. Spoofax uses dependency injection to inject required services, tasks, and other objects into the objects of your classes. The classloaderResources object used in (4) is of type HelloWorldClassLoaderResources which is class that Spoofax generates for your language. Similarly, the parse object used in (5) is of type HelloWorldParse which is a task definition that Spoofax generates for you. We store these as fields of this class. Note that dependency injection, and file/task dependencies in PIE, are two completely separate things. These fields are set using constructor injection in the single constructor of this class marked with @Inject . The dependency injection framework that Spoofax uses (the Dagger framework) will then instantiate your class with instances of the dependencies. Finally, we must tell the dependency injection framework to which scope instances of this class belongs. We annotate the class with @HelloWorldScope which is a scope annotation that Spoofax generates for you. This is mainly used to differentiate between different languages when multiple languages are composed, which we do not do in this tutorial, but is required nonetheless. Registering the task definition \u00b6 We must register this task in order for Spoofax to know about it. Open the CFG helloworld/spoofax.cfg file. The CFG meta-language is a configuration language where we configure and glue together the various aspects of your language. Add the following configuration to the end of the file: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst This registers the task definition class that we just created, and makes it available under the showParsedAst name in the configuration. Warning Spoofax assumes that this class implements TaskDef . This is not checked as part of this configuration. Faults will lead to Java compile errors. Creating the command \u00b6 To create the command, add the following configuration to the end of the spoofax.cfg file: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand // (1) task-def = showParsedAst // (2) args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args // (3) display-name = \"Show parsed AST\" // (4) description = \"Shows the parsed AST\" // (5) supported-execution-types = [Once, Continuous] // (6) parameters = [ // (7) file = parameter { (7a) type = java mb.resource.ResourceKey (7b) required = true (7c) argument-providers = [Context(File)] (7d) } ] } Spoofax generates a Java class implementing the command boilerplate for you. This is the fully qualified Java type we want this command to have. Can be omitted to generate a type based on the name of the task definition. The task definition that the command will execute, which is the showParsedAst we defined earlier. The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. The display name of the command. The optional description of the command. The optional supported execution types of the command. Once indicates a one-shot command, while Continuous indicates a command that is executed every time the source file changes. Defaults to [Once, Continuous] . The description of the parameters of the command: The name of the parameter. The fully qualified Java of the type of the parameter. This must match the type we used in the HelloWorldShowParsedAst . Args class before. Whether the parameter is required. Defaults to true . Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. Because this argument is a file, we want to try to infer the file from context, so we use Context(File) . When we execute this command on a \"Hello world\" file in the IDE, Spoofax will automatically infer that file as the argument for the parameter. Currently, Spoofax does not support running commands in the IDE without an argument provider, so a working argument provider is currently required. Warning Spoofax assumes that: a) the task definition's input type is the one defined at (3), b) the output type is CommandFeedback , and c) that the argument type has a constructor covering exactly the parameters from (7). This is not checked as part of this configuration. Faults will lead to Java compile errors. Some properties set above are set to their conventional (default) value, or are optional, so we can leave them out. Replace the command definition with the following code: let showParsedAstCommand = command-def { task-def = showParsedAst display-name = \"Show parsed AST\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(File)] } ] } Adding the menu item \u00b6 To add the menu item, add the following configuration to the end of the spoofax.cfg file: editor-context-menu [ // (1) menu \"Debug\" [ // (2) command-action { // (3) command-def = showParsedAstCommand // (3a) execution-type = Once // (3b) } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ // (4) menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] // (5) } ] ] An editor-context-menu section adds menu items to the editor context menu. That is, the menu that pops up when you right-click inside an editor for your language. There is also a main-menu section for adding menu items to the main menu when an editor for your language has focus. If no main-menu section is defined, the main menu will take all menu items from editor-context-menu . A nested menu with name \"Debug\" . An action menu item that executes a command. The command to execute. How the command should be executed. Once to execute it once, Continuous to continuously execute the command when the source file changes. A resource-context-menu section adds menu items to the context menu of the resource browser. That is, the menu that pops up when you right-click a file of your language. For menu items inside a resource-context-menu to show up, they must specify on what kind of resource types they are shown. In this case, we want the command to show up for files of our language, so we choose [File] . Build the project so that we can test our changes. Open the test.hel file and right-click inside the editor area to open the context menu. From the editor context menu, select HelloWorld \u2023 Debug \u2023 Show parsed AST . A new editor will pop up with the result of the command, showing the AST of your example file. Close the result and now run HelloWorld \u2023 Debug \u2023 Show parsed AST (continuous) . Drag the resulting editor to the side and edit the example project, the resulting editor will update whenever the example file changes. We can also run the command by activating the test.hel editor by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the main menu. Finally, we can run the command by right-clicking the test.hel file in the Package Explorer by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the context menu. Changing the static semantics \u00b6 Now we will fix the static semantics of the language. Open the main Statix file helloworld/src/main.stx Statix is a meta-language for defining the static semantics of your language, which includes type checking. First we will update the Statix specification to handle the new language constructs. Replace the signature section with the following: signature sorts Start constructors Program : list ( Part ) -> Start sorts Part constructors Hello : Part World : Part This defines the AST signature of the language. In a future version of Spoofax 3, this will be automatically derived from the SDF3 specification. Now, replace the programOk ( Empty ()). line with programOk ( Program ( parts )). , meaning that we accept all programs consisting of parts, which is always true due to the syntax of the language. The file should now look like this: module main signature sorts Start constructors Program : list ( Part ) -> Start sorts Part constructors Hello : Part World : Part rules programOk : Start programOk ( Program ( parts )). Build the project, and the error marker should disappear from your example program. As a silly rule, we will add a warning to all instances of world in the program. Add the following code to the end of the Statix definition: partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) This adds a partOk rule that lets all Hello () parts pass, but will add a warning to all World () parts. partsOk goes over a list of parts and applies partOk . Replace the programOk ( Program ( parts )). line with programOk ( Program ( parts )) : - partsOk ( parts ). to apply the partsOk rule. Build the project, and a warning marker should appear under all instances of world in the program. Adding a transformation \u00b6 Finally, we will define a transformation for our language and add a task, command-tasks, command, and menu item for it. Open the main Stratego file helloworld/src/main.str . Stratego is a meta-language for defining term ( AST ) transformations through rewrite rules. We will add a silly transformation that replaces all instances of World () with Hello () . Add the following code to the end of the Stratego file: rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) The replace-world rule passes Hello () terms but rewrites World () terms to Hello () . The replace-worlds strategy tries to apply replace-world in a top-down manner over the entire AST . Now we add a task and command-task for this transformation. We define two separate tasks to keep separate the act of transforming the program, and feeding back the result of that transformation to the user that executes a command. This practice later allows us to reuse the first task in a different task if we need to. Right-click the mb.helloworld.task package and create the HelloWorldReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package mb.helloworld.task ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.stratego.pie.AstStrategoTransformTaskDef ; import javax.inject.Inject ; import java.io.IOException ; @HelloWorldScope public class HelloWorldReplaceWorlds extends AstStrategoTransformTaskDef { private final HelloWorldClassLoaderResources classloaderResources ; @Inject public HelloWorldReplaceWorlds ( // 1 HelloWorldClassLoaderResources classloaderResources , HelloWorldGetStrategoRuntimeProvider getStrategoRuntimeProvider ) { super ( getStrategoRuntimeProvider , \"replace-worlds\" ); // 2 this . classloaderResources = classloaderResources ; } @Override public String getId () { // 3 return getClass (). getName (); } @Override protected void createDependencies ( ExecContext context ) throws IOException { // 4 context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); } } This task extends AstStrategoTransformTaskDef which is a convenient abstract class for creating tasks that run Stratego transformations by implementing a constructor and a couple of methods: The constructor should inject HelloWorldClassLoaderResources which we again will use to create a self-dependency, and HelloWorldGetStrategoRuntimeProvider which is a task that Spoofax generates for your language, which provides a Stratego runtime to execute strategies with. The HelloWorldGetStrategoRuntimeProvider instance is provided to the superclass constructor, along with the strategy that we want this task to execute, which is \"replace-worlds\" . We override getId of TaskDef again to give this task a unique identifier. We override createDependencies of AstStrategoTransformTaskDef to create a self-dependency. Then create the HelloWorldShowReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.stratego.common.StrategoUtil ; @HelloWorldScope public class HelloWorldShowReplaceWorlds implements TaskDef < HelloWorldShowReplaceWorlds . Args , CommandFeedback > { public static class Args implements Serializable { private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; private final HelloWorldReplaceWorlds replaceWorlds ; @Inject public HelloWorldShowReplaceWorlds ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse , HelloWorldReplaceWorlds replaceWorlds ) { this . classloaderResources = classloaderResources ; this . parse = parse ; this . replaceWorlds = replaceWorlds ; } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); final ResourceKey file = args . file ; return context . require ( replaceWorlds , parse . inputBuilder (). withFile ( file ). buildAstSupplier ()). mapOrElse ( ast -> CommandFeedback . of ( ShowFeedback . showText ( StrategoUtil . toString ( ast ), \"Replaced World()s with Hello()s for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { return getClass (). getName (); } } This class very similar to HelloWorldShowParsedAst , but runs the HelloWorldReplaceWorlds task on the parsed AST , transforming the AST . Now open helloworld/spoofax.cfg again and register the tasks by adding: task-def mb.helloworld.task.HelloWorldReplaceWorlds let showReplaceWorlds = task-def mb.helloworld.task.HelloWorldShowReplaceWorlds Then add a command for it by adding: let showReplaceWorldsCommand = command-def { task-def = showReplaceWorlds display-name = \"Replace world with hello\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(File)] } ] } Finally, add menu items for the command by adding: editor-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once } command-action { command-def = showReplaceWorldsCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once required-resource-types = [File] } ] ] Build the project so that we can test our changes. Test the command similarly to testing the \"Show parsed AST \" command.","title":"Creating a language project"},{"location":"tutorial/create_language_project/#creating-a-language-project","text":"This tutorial gets you started with language development by creating a language project and changing various aspects of the language. First follow the installation tutorial if you haven't done so yet.","title":"Creating a language project"},{"location":"tutorial/create_language_project/#creating-a-new-project","text":"In Eclipse, open the new project dialog by choosing File \u2023 New \u2023 Project from the main menu. In the new project dialog, select Spoofax LWB \u2023 Spoofax language project and press Next . In this wizard, you can customize the various names your language will use. However, for the purpose of this tutorial, fill in HelloWorld as the name of the project, which will automatically fill in the other elements with defaults. Then press Finish to create the project. There should now be a project named helloworld in the Package Explorer .","title":"Creating a new project"},{"location":"tutorial/create_language_project/#adding-syntax","text":"First we will add some syntax to the language. Open the main SDF3 file helloworld/src/start.sdf3 file by expanding the folders and double-clicking the file. SDF3 is a meta-language (i.e., a language to describe languages) for describing the syntax of a language, from which Spoofax will derive the parser of your language. Under the context-free syntax section, replace the Start . Empty = <> line with Start . Program = <<{ Part \" \" } * >> , indicating that the language accepts programs which consists of one or more parts. Then add Part . Hello = < hello > on a new line, indicating that one sort of part is the word hello. Finally, add Part . World = < world > on a new line, indicating that one sort of part is the word world . The context-free syntax section should now look as follows: context-free syntax Start . Program = <<{ Part \" \" } * >> Part . Hello = < hello > Part . World = < world > To test our change, build the project by clicking on the project in the Package Explorer and choosing Project \u2023 Build Project from the main menu, or by pressing Cmd + B on macOS or Ctrl + B on others. To see when the build is done, open the progress window by choosing Window \u2023 Show View \u2023 Progress . If the progress view is empty, the build is done. The initial build can be a bit slow because there is a lot of code to compile in the background. Subsequent builds will be faster due to incrementalization. Create a test file for your language by right-clicking the project and choosing New \u2023 File , filling in test.hel as file name, and pressing Finish . Type a valid sentence such as hello world hello hello world in this file, and it will highlight purple indicating that hello and world are keywords. There will also be an error marker on the file because we have not yet updated the static semantics (i.e., type checker) of the language to handle the language constructs we just added. That is ok for now, we will fix this later.","title":"Adding syntax"},{"location":"tutorial/create_language_project/#changing-syntax-highlighting","text":"Now we will change the syntax highlighter of the language. Open the main ESV file helloworld/src/main.esv . ESV is a meta-language for describing the syntax highlighter. Change the keyword : 127 0 85 bold line to keyword : 0 0 150 bold and build the project. Then check your test.hel example file, it should now be highlighted blue. To make iteration easier, you can drag the test.hel tab to the side of the screen to open the language definition and example file side-by-side. You can play around with the coloring a bit and choose a style to your liking. Remember to rebuild the project after making a change to the language definition.","title":"Changing syntax highlighting"},{"location":"tutorial/create_language_project/#adding-a-debugging-command","text":"It can be quite handy to look at the AST of a program that the parser of the language produces as a debugging tool. To do that, we will write a task definition that produces the AST of a program by parsing it, we will add a command definition for that task, and finally we will bind the command to a menu item so that we can execute the command.","title":"Adding a debugging command"},{"location":"tutorial/create_language_project/#creating-the-task-definition","text":"A task definition is a piece of code that take some input, may read from or write to files, run and get the result of other tasks, and produce some output. Task definitions come from PIE , a framework for developing composable, incremental, correct, and expressive pipelines and build scripts. All user interaction, pipelines, and builds in Spoofax 3 are composed of task definitions. So whenever you want to perform a command, present feedback to the user, or compile your language, you will need to write a task definition for it. For brevity, we usually just refer to a \"task definition\" by \"task\". For PIE to be able to incrementally execute your task, you must make your dependencies explicit. That is, dependencies to files and other tasks must be made explicit. However, because PIE supports dynamic dependencies , those dependencies are made while the build script is executing . A full tutorial on PIE is outside the scope of this tutorial, but we will implement several tasks in this tutorial, explain the PIE concepts, and how Spoofax 3 uses these concepts. A task definition is written as a class in Java, and needs to adhere to a certain interface. Let's start by creating the class for this task. First, right-click the helloworld/src/main/java directory and choose New \u2023 Package , replace the name with mb.helloworld.task , and press Finish . Then, right-click the mb.helloworld.task package we just created and choose New \u2023 Class and fill in HelloWorldShowParsedAst as name, then press Finish . Replace the entire Java file with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import org.spoofax.interpreter.terms.IStrategoTerm ; import mb.common.result.Result ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.jsglr1.common.JSGLR1ParseException ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.stratego.common.StrategoUtil ; @HelloWorldScope // (10) public class HelloWorldShowParsedAst implements TaskDef < HelloWorldShowParsedAst . Args , CommandFeedback > { // (1) public static class Args implements Serializable { // (2) private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { // (3) context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); // (4) final ResourceKey file = args . file ; final Result < IStrategoTerm , JSGLR1ParseException > astResult = context . require ( parse . inputBuilder (). withFile ( file ). buildAstSupplier ()); // (5) return astResult . mapOrElse ( // (6) ast -> CommandFeedback . of ( ShowFeedback . showText ( StrategoUtil . toString ( ast ), \"Parsed AST for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { // (7) return getClass (). getName (); } // (8) private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; @Inject // (9) public HelloWorldShowParsedAst ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse ) { this . classloaderResources = classloaderResources ; this . parse = parse ; } } We explain this class with numbered annotations in the above Java source file: This class implements TaskDef , which is an interface from PIE which a class must implement to be a task definition. Task definitions have an input and output type defined by the first and second generic argument. To execute this task, an object of the input type is required, and once it is done executing, it must return an object of the output type. In this concrete case, the input type is HelloWorldShowParsedAst . Args which is a nested data class defined at (2). The output is CommandFeedback which is a type defined by Spoofax for providing feedback back to the user when executing a command. All tasks that are executed through commands must return a CommandFeedback object. A nested data class encapsulating the input to this task. In this case, we want this task to take the file we are going to show the AST of as input. Even though we only take one argument as input, we must encapsulate it in a class due to the way commands in Spoofax work. This data class must implement Serializable because it is used as an input to a task. In order for PIE to incrementalize tasks across JVM restarts, it must be able to serialize the input (and output) objects to disk. Furthermore, this class must be immutable, because PIE caches input (and output) objects, and this caching would be inconsistent if the class is mutable. This class is immutable by storing the file in a final field which is set in the constructor (and the ResourceKey class is immutable as well). Spoofax and PIE abstract over files with resources . A resource is some externally managed mutable state, with a (immutable and serializable) key which can be used to identify, read, and write to that resource. Such a key is represented by a ResourceKey . Finally, this data class must implement equals and hashCode according to the data in the class because PIE uses these methods to identify tasks according to their input, which in turn is used for caching. A toString implementation is also recommended for debugging. The exec method which is called when the task is executed. It takes an ExecContext as input, which is used to tell PIE about dependencies to files, and can be used to execute and get the result of another task (implicitly creating a dependency to that task). It also takes the input type Args as input, and must return a CommandFeedback . For sound incrementality, we want to re-execute this task when we make changes to this class. Therefore, we want to make a self-dependency . That is, we want to make a file dependency to the Java class file that is compiled from this Java source file. The classloaderResources object (defined below at (8)) is used to get the class or JAR file of the current class. This resource is passed to context . require to tell PIE that this task depends on that file. We pass in ResourceStampers . hashFile () as the second argument, which indicates that we want to use the hash of the class file to detect changes, instead of the last modified date which is used by default. It is recommended to use hashes for dependencies to generated/compiled files, as compiled files are sometimes recompiled without changes, which changes the modified date but not the hash, leading to better incrementality. To show the AST we must parse the input file, and in order to do that we must call a task which performs the parsing. Whereas (4) uses context . require to create a dependency to a file , we use context . require here to create a dependency to the task that does the parsing, and get the output of that task. As input to context . require we pass parse . inputBuilder (). withFile ( file ). buildAstSupplier () , which uses the builder pattern to create an input for the parse task and then extracts the AST from the output. Internally, the parse task creates a dependency to the file we pass into it. We depend on the parse task. Therefore, when the file changes, PIE re-executes the parse task, and then re-executes this task if the output of the parse task is different. Thereby, PIE incrementally executes your task without having to incrementalize it yourself. The output of the parse task is Result < IStrategoTerm , JSGLR1ParseException > which is a result type which is either a IStrategoTerm representing the AST of the file if parsing succeeds, or a JSGLR1ParseException when parsing fails. Instead of throwing exceptions, we use result types (akin to Either in Haskell or Result in Rust) to model the possibility of failure with values. We do this to make it possible to work with failures in PIE tasks. In PIE, throwing an exception signifies an unrecoverable error and cancels the entire pipeline. However, using failures as values works normally. Now that we have the result of parsing, we can turn it into a CommandFeedback object. We use mapOrElse of Result to map the result to a CommandFeedback differently depending on whether parsing succeeded or failed. If parsing succeeded, we show the AST as text to the user with CommandFeedback . of ( ShowFeedback . showText (...)) with the first argument providing the text, and the second argument providing the title. The IDE then shows this as a textual editor. If parsing failed, we present the parse error messages as feedback to the user with CommandFeedback . ofTryExtractMessagesFrom . Finally, PIE needs to be able to identify this task definition. That is done by this getId method that returns a unique identifier. This can almost always be implemented using getClass (). getName () which returns the fully qualified name of this class. Spoofax uses dependency injection to inject required services, tasks, and other objects into the objects of your classes. The classloaderResources object used in (4) is of type HelloWorldClassLoaderResources which is class that Spoofax generates for your language. Similarly, the parse object used in (5) is of type HelloWorldParse which is a task definition that Spoofax generates for you. We store these as fields of this class. Note that dependency injection, and file/task dependencies in PIE, are two completely separate things. These fields are set using constructor injection in the single constructor of this class marked with @Inject . The dependency injection framework that Spoofax uses (the Dagger framework) will then instantiate your class with instances of the dependencies. Finally, we must tell the dependency injection framework to which scope instances of this class belongs. We annotate the class with @HelloWorldScope which is a scope annotation that Spoofax generates for you. This is mainly used to differentiate between different languages when multiple languages are composed, which we do not do in this tutorial, but is required nonetheless.","title":"Creating the task definition"},{"location":"tutorial/create_language_project/#registering-the-task-definition","text":"We must register this task in order for Spoofax to know about it. Open the CFG helloworld/spoofax.cfg file. The CFG meta-language is a configuration language where we configure and glue together the various aspects of your language. Add the following configuration to the end of the file: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst This registers the task definition class that we just created, and makes it available under the showParsedAst name in the configuration. Warning Spoofax assumes that this class implements TaskDef . This is not checked as part of this configuration. Faults will lead to Java compile errors.","title":"Registering the task definition"},{"location":"tutorial/create_language_project/#creating-the-command","text":"To create the command, add the following configuration to the end of the spoofax.cfg file: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand // (1) task-def = showParsedAst // (2) args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args // (3) display-name = \"Show parsed AST\" // (4) description = \"Shows the parsed AST\" // (5) supported-execution-types = [Once, Continuous] // (6) parameters = [ // (7) file = parameter { (7a) type = java mb.resource.ResourceKey (7b) required = true (7c) argument-providers = [Context(File)] (7d) } ] } Spoofax generates a Java class implementing the command boilerplate for you. This is the fully qualified Java type we want this command to have. Can be omitted to generate a type based on the name of the task definition. The task definition that the command will execute, which is the showParsedAst we defined earlier. The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. The display name of the command. The optional description of the command. The optional supported execution types of the command. Once indicates a one-shot command, while Continuous indicates a command that is executed every time the source file changes. Defaults to [Once, Continuous] . The description of the parameters of the command: The name of the parameter. The fully qualified Java of the type of the parameter. This must match the type we used in the HelloWorldShowParsedAst . Args class before. Whether the parameter is required. Defaults to true . Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. Because this argument is a file, we want to try to infer the file from context, so we use Context(File) . When we execute this command on a \"Hello world\" file in the IDE, Spoofax will automatically infer that file as the argument for the parameter. Currently, Spoofax does not support running commands in the IDE without an argument provider, so a working argument provider is currently required. Warning Spoofax assumes that: a) the task definition's input type is the one defined at (3), b) the output type is CommandFeedback , and c) that the argument type has a constructor covering exactly the parameters from (7). This is not checked as part of this configuration. Faults will lead to Java compile errors. Some properties set above are set to their conventional (default) value, or are optional, so we can leave them out. Replace the command definition with the following code: let showParsedAstCommand = command-def { task-def = showParsedAst display-name = \"Show parsed AST\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(File)] } ] }","title":"Creating the command"},{"location":"tutorial/create_language_project/#adding-the-menu-item","text":"To add the menu item, add the following configuration to the end of the spoofax.cfg file: editor-context-menu [ // (1) menu \"Debug\" [ // (2) command-action { // (3) command-def = showParsedAstCommand // (3a) execution-type = Once // (3b) } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ // (4) menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] // (5) } ] ] An editor-context-menu section adds menu items to the editor context menu. That is, the menu that pops up when you right-click inside an editor for your language. There is also a main-menu section for adding menu items to the main menu when an editor for your language has focus. If no main-menu section is defined, the main menu will take all menu items from editor-context-menu . A nested menu with name \"Debug\" . An action menu item that executes a command. The command to execute. How the command should be executed. Once to execute it once, Continuous to continuously execute the command when the source file changes. A resource-context-menu section adds menu items to the context menu of the resource browser. That is, the menu that pops up when you right-click a file of your language. For menu items inside a resource-context-menu to show up, they must specify on what kind of resource types they are shown. In this case, we want the command to show up for files of our language, so we choose [File] . Build the project so that we can test our changes. Open the test.hel file and right-click inside the editor area to open the context menu. From the editor context menu, select HelloWorld \u2023 Debug \u2023 Show parsed AST . A new editor will pop up with the result of the command, showing the AST of your example file. Close the result and now run HelloWorld \u2023 Debug \u2023 Show parsed AST (continuous) . Drag the resulting editor to the side and edit the example project, the resulting editor will update whenever the example file changes. We can also run the command by activating the test.hel editor by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the main menu. Finally, we can run the command by right-clicking the test.hel file in the Package Explorer by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the context menu.","title":"Adding the menu item"},{"location":"tutorial/create_language_project/#changing-the-static-semantics","text":"Now we will fix the static semantics of the language. Open the main Statix file helloworld/src/main.stx Statix is a meta-language for defining the static semantics of your language, which includes type checking. First we will update the Statix specification to handle the new language constructs. Replace the signature section with the following: signature sorts Start constructors Program : list ( Part ) -> Start sorts Part constructors Hello : Part World : Part This defines the AST signature of the language. In a future version of Spoofax 3, this will be automatically derived from the SDF3 specification. Now, replace the programOk ( Empty ()). line with programOk ( Program ( parts )). , meaning that we accept all programs consisting of parts, which is always true due to the syntax of the language. The file should now look like this: module main signature sorts Start constructors Program : list ( Part ) -> Start sorts Part constructors Hello : Part World : Part rules programOk : Start programOk ( Program ( parts )). Build the project, and the error marker should disappear from your example program. As a silly rule, we will add a warning to all instances of world in the program. Add the following code to the end of the Statix definition: partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) This adds a partOk rule that lets all Hello () parts pass, but will add a warning to all World () parts. partsOk goes over a list of parts and applies partOk . Replace the programOk ( Program ( parts )). line with programOk ( Program ( parts )) : - partsOk ( parts ). to apply the partsOk rule. Build the project, and a warning marker should appear under all instances of world in the program.","title":"Changing the static semantics"},{"location":"tutorial/create_language_project/#adding-a-transformation","text":"Finally, we will define a transformation for our language and add a task, command-tasks, command, and menu item for it. Open the main Stratego file helloworld/src/main.str . Stratego is a meta-language for defining term ( AST ) transformations through rewrite rules. We will add a silly transformation that replaces all instances of World () with Hello () . Add the following code to the end of the Stratego file: rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) The replace-world rule passes Hello () terms but rewrites World () terms to Hello () . The replace-worlds strategy tries to apply replace-world in a top-down manner over the entire AST . Now we add a task and command-task for this transformation. We define two separate tasks to keep separate the act of transforming the program, and feeding back the result of that transformation to the user that executes a command. This practice later allows us to reuse the first task in a different task if we need to. Right-click the mb.helloworld.task package and create the HelloWorldReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package mb.helloworld.task ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.stratego.pie.AstStrategoTransformTaskDef ; import javax.inject.Inject ; import java.io.IOException ; @HelloWorldScope public class HelloWorldReplaceWorlds extends AstStrategoTransformTaskDef { private final HelloWorldClassLoaderResources classloaderResources ; @Inject public HelloWorldReplaceWorlds ( // 1 HelloWorldClassLoaderResources classloaderResources , HelloWorldGetStrategoRuntimeProvider getStrategoRuntimeProvider ) { super ( getStrategoRuntimeProvider , \"replace-worlds\" ); // 2 this . classloaderResources = classloaderResources ; } @Override public String getId () { // 3 return getClass (). getName (); } @Override protected void createDependencies ( ExecContext context ) throws IOException { // 4 context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); } } This task extends AstStrategoTransformTaskDef which is a convenient abstract class for creating tasks that run Stratego transformations by implementing a constructor and a couple of methods: The constructor should inject HelloWorldClassLoaderResources which we again will use to create a self-dependency, and HelloWorldGetStrategoRuntimeProvider which is a task that Spoofax generates for your language, which provides a Stratego runtime to execute strategies with. The HelloWorldGetStrategoRuntimeProvider instance is provided to the superclass constructor, along with the strategy that we want this task to execute, which is \"replace-worlds\" . We override getId of TaskDef again to give this task a unique identifier. We override createDependencies of AstStrategoTransformTaskDef to create a self-dependency. Then create the HelloWorldShowReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.stratego.common.StrategoUtil ; @HelloWorldScope public class HelloWorldShowReplaceWorlds implements TaskDef < HelloWorldShowReplaceWorlds . Args , CommandFeedback > { public static class Args implements Serializable { private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; private final HelloWorldReplaceWorlds replaceWorlds ; @Inject public HelloWorldShowReplaceWorlds ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse , HelloWorldReplaceWorlds replaceWorlds ) { this . classloaderResources = classloaderResources ; this . parse = parse ; this . replaceWorlds = replaceWorlds ; } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); final ResourceKey file = args . file ; return context . require ( replaceWorlds , parse . inputBuilder (). withFile ( file ). buildAstSupplier ()). mapOrElse ( ast -> CommandFeedback . of ( ShowFeedback . showText ( StrategoUtil . toString ( ast ), \"Replaced World()s with Hello()s for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { return getClass (). getName (); } } This class very similar to HelloWorldShowParsedAst , but runs the HelloWorldReplaceWorlds task on the parsed AST , transforming the AST . Now open helloworld/spoofax.cfg again and register the tasks by adding: task-def mb.helloworld.task.HelloWorldReplaceWorlds let showReplaceWorlds = task-def mb.helloworld.task.HelloWorldShowReplaceWorlds Then add a command for it by adding: let showReplaceWorldsCommand = command-def { task-def = showReplaceWorlds display-name = \"Replace world with hello\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(File)] } ] } Finally, add menu items for the command by adding: editor-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once } command-action { command-def = showReplaceWorldsCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once required-resource-types = [File] } ] ] Build the project so that we can test our changes. Test the command similarly to testing the \"Show parsed AST \" command.","title":"Adding a transformation"},{"location":"tutorial/install/","text":"Installing the Spoofax 3 language workbench \u00b6 This tutorial gets you set up for language development in Spoofax 3 by installing the Spoofax 3 Eclipse LWB environment. Requirements \u00b6 Spoofax 3 runs on the major operating systems: Windows (64 bits) macOS (64 bits) Linux (64 bits) Other than that, nothing is required as everything is contained in the archive we are going to download. Download \u00b6 To get started, we will download a premade Eclipse installation that comes bundled with the Spoofax 3 LWB plugin. Download the latest version for your platform: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM These are bundled with an embedded JVM so that you do not need to have a JVM installed. If your system has a JVM of version 11 or higher installed, and would rather use that, use the following download links instead: Windows 64-bit macOS 64-bit Linux 64-bit Unpack \u00b6 Unpack the downloaded archive to a directory with write access. Write access is required because Eclipse needs to write to several configuration files inside its installation. Warning The unpacked directory or application may be renamed, but do not include spaces or other characters that would not be allowed in a URI (i.e., : ? # [ ] @ ). The same is true for the directory the archive is extracted to. Failing to do so breaks a built-in classpath detection mechanism which will cause Java compilation errors. Warning On Windows do not unpack the Eclipse installation into Program Files , because no write access is granted there, breaking both Eclipse and Spoofax. Running Eclipse \u00b6 Start up Eclipse, depending on your operating system: Windows: run Spoofax3/eclipse.exe macOS run Spoofax3.app Linux run Spoofax3/eclipse Warning macOS Sierra (10.12) and above will mark the unpacked Spoofax3.app as \"damaged\" due to a modified signed/notarized application, because we have modified the eclipse.ini file inside it. To fix this, open the Terminal, navigate to the directory where the Spoofax3.app file is located, and execute: xattr -rc Spoofax3.app After starting up, choose where your workspace will be stored. The Eclipse workspace will contain all of your settings, and is the default location for new projects. Configuring Eclipse's preferences \u00b6 Some Eclipse preferences unfortunately have sub-optimal defaults. After you have chosen a workspace and Eclipse has completely started up (and you have closed the Welcome page), go to the Eclipse preferences by pressing Cmd + , on macOS and ??? on others, and set these options: General \u2023 Startup and Shutdown Enable: Refresh workspace on startup General \u2023 Workspace Enable: Refresh using native hooks or polling General \u2023 Workspace \u2023 Build Enable: Save automatically before manual build Finally, we need to make sure that Eclipse has detected an installed JRE . Open the Eclipse preferences and go to the Java \u2023 Installed JREs page: If there are no installed JREs, and you've downloaded an Eclipse installation with an embedded JVM , press Search... and navigate to the location where you unpacked the Eclipse installation, and choose the jvm directory in it. Then press the checkmark of the JRE to activate it. If there are no installed JREs, and you've downloaded an Eclipse installation without an embedded JVM , press Search... and navigate to the location where your JVM installed, and choose it. Then press the checkmark of the JRE to activate it. If there are one or more installed JVMs, but none are selected, select an appropriate one by pressing the checkmark. If there are one or more installed JVMs, and one is selected, you are good to go. Tip These preferences are stored per workspace. If you create a fresh workspace, you have to re-do these settings. You can create a new workspace with copied preferences by selecting File \u2023 Switch workspace \u2023 Other... , and then checking Preferences under Copy settings . Now that Eclipse is set up, continue with creating a language project","title":"Installing the Spoofax 3 language workbench"},{"location":"tutorial/install/#installing-the-spoofax-3-language-workbench","text":"This tutorial gets you set up for language development in Spoofax 3 by installing the Spoofax 3 Eclipse LWB environment.","title":"Installing the Spoofax 3 language workbench"},{"location":"tutorial/install/#requirements","text":"Spoofax 3 runs on the major operating systems: Windows (64 bits) macOS (64 bits) Linux (64 bits) Other than that, nothing is required as everything is contained in the archive we are going to download.","title":"Requirements"},{"location":"tutorial/install/#download","text":"To get started, we will download a premade Eclipse installation that comes bundled with the Spoofax 3 LWB plugin. Download the latest version for your platform: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM These are bundled with an embedded JVM so that you do not need to have a JVM installed. If your system has a JVM of version 11 or higher installed, and would rather use that, use the following download links instead: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Download"},{"location":"tutorial/install/#unpack","text":"Unpack the downloaded archive to a directory with write access. Write access is required because Eclipse needs to write to several configuration files inside its installation. Warning The unpacked directory or application may be renamed, but do not include spaces or other characters that would not be allowed in a URI (i.e., : ? # [ ] @ ). The same is true for the directory the archive is extracted to. Failing to do so breaks a built-in classpath detection mechanism which will cause Java compilation errors. Warning On Windows do not unpack the Eclipse installation into Program Files , because no write access is granted there, breaking both Eclipse and Spoofax.","title":"Unpack"},{"location":"tutorial/install/#running-eclipse","text":"Start up Eclipse, depending on your operating system: Windows: run Spoofax3/eclipse.exe macOS run Spoofax3.app Linux run Spoofax3/eclipse Warning macOS Sierra (10.12) and above will mark the unpacked Spoofax3.app as \"damaged\" due to a modified signed/notarized application, because we have modified the eclipse.ini file inside it. To fix this, open the Terminal, navigate to the directory where the Spoofax3.app file is located, and execute: xattr -rc Spoofax3.app After starting up, choose where your workspace will be stored. The Eclipse workspace will contain all of your settings, and is the default location for new projects.","title":"Running Eclipse"},{"location":"tutorial/install/#configuring-eclipses-preferences","text":"Some Eclipse preferences unfortunately have sub-optimal defaults. After you have chosen a workspace and Eclipse has completely started up (and you have closed the Welcome page), go to the Eclipse preferences by pressing Cmd + , on macOS and ??? on others, and set these options: General \u2023 Startup and Shutdown Enable: Refresh workspace on startup General \u2023 Workspace Enable: Refresh using native hooks or polling General \u2023 Workspace \u2023 Build Enable: Save automatically before manual build Finally, we need to make sure that Eclipse has detected an installed JRE . Open the Eclipse preferences and go to the Java \u2023 Installed JREs page: If there are no installed JREs, and you've downloaded an Eclipse installation with an embedded JVM , press Search... and navigate to the location where you unpacked the Eclipse installation, and choose the jvm directory in it. Then press the checkmark of the JRE to activate it. If there are no installed JREs, and you've downloaded an Eclipse installation without an embedded JVM , press Search... and navigate to the location where your JVM installed, and choose it. Then press the checkmark of the JRE to activate it. If there are one or more installed JVMs, but none are selected, select an appropriate one by pressing the checkmark. If there are one or more installed JVMs, and one is selected, you are good to go. Tip These preferences are stored per workspace. If you create a fresh workspace, you have to re-do these settings. You can create a new workspace with copied preferences by selecting File \u2023 Switch workspace \u2023 Other... , and then checking Preferences under Copy settings . Now that Eclipse is set up, continue with creating a language project","title":"Configuring Eclipse's preferences"}]}