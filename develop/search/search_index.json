{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spoofax 3 \u00b6 Spoofax 3 is a modular and incremental textual language workbench running on the JVM : a collection of tools and Java libraries that enable the development of textual languages, embeddable into batch compilers, code editors and IDEs, or custom applications. It is a reimplementation of Spoofax 2 , with the goal of being more modular, flexible, and correctly incremental. This documentation website aims to cover language development with Spoofax 3, development of the language workbench itself (e.g., meta-language development), and development of this documentation. Currently, Spoofax 3 is experimental and still a work-in-progress. Therefore, it does not have a stable API, lacks documentation and test coverage, and has not yet been applied to real-world use cases. If you are looking for a more mature alternative, see Spoofax 2 , which Spoofax 3 is based on. The documentation for Spoofax 3 is split into five parts: Tutorials : hands-on tutorials to getting you started with Spoofax 3. How-to guides : step-by-step guides showing how to implement certain features or how to solve common problems. (Under construction) Reference : technical reference describing the various facets of Spoofax 3. Background : background information and discussion on various key topics. Releases : download links, changelogs, and migration guides.","title":"Home"},{"location":"#spoofax-3","text":"Spoofax 3 is a modular and incremental textual language workbench running on the JVM : a collection of tools and Java libraries that enable the development of textual languages, embeddable into batch compilers, code editors and IDEs, or custom applications. It is a reimplementation of Spoofax 2 , with the goal of being more modular, flexible, and correctly incremental. This documentation website aims to cover language development with Spoofax 3, development of the language workbench itself (e.g., meta-language development), and development of this documentation. Currently, Spoofax 3 is experimental and still a work-in-progress. Therefore, it does not have a stable API, lacks documentation and test coverage, and has not yet been applied to real-world use cases. If you are looking for a more mature alternative, see Spoofax 2 , which Spoofax 3 is based on. The documentation for Spoofax 3 is split into five parts: Tutorials : hands-on tutorials to getting you started with Spoofax 3. How-to guides : step-by-step guides showing how to implement certain features or how to solve common problems. (Under construction) Reference : technical reference describing the various facets of Spoofax 3. Background : background information and discussion on various key topics. Releases : download links, changelogs, and migration guides.","title":"Spoofax 3"},{"location":"info/","text":"Macros Plugin Environment \u00b6 General List \u00b6 All available variables and filters within the macros plugin: Variable Type Content extra dict config Config config_file_path = '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml', site_name = 'Spoofax 3', nav = [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/configuration.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}], pages [ NoneType ], site_url = '', site_description = 'Spoofax 3 documentation website', site_author [ NoneType ], theme [ Theme ], docs_dir = '/home/runner/work/spoofax-pie/spoofax-pie/docs', site_dir = '/home/runner/work/spoofax-pie/spoofax-pie/site', copyright [ NoneType ], google_analytics [ NoneType ], dev_addr [ Address ], use_directory_urls = True, repo_url = 'https://github.com/metaborg/spoofax-pie/', repo_name = 'metaborg/spoofax-pie', edit_uri = 'edit/master/docs/', extra_css = ['extra.css'], extra_javascript = [], extra_templates = [], markdown_extensions = ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'], mdx_configs [ dict ], strict = False, remote_branch = 'gh-pages', remote_name = 'origin', extra [ SubConfig ], plugins [ PluginCollection ] environment dict system = 'Linux', system_version = '5.4.0-1055-azure', python_version = '3.8.11', mkdocs_version = '1.2.2', macros_plugin_version = '0.5.5', jinja2_version = '3.0.1' plugin Config module_name = 'docs/macro', modules = [], include_dir = '', include_yaml = [], j2_block_start_string = '', j2_block_end_string = '', j2_variable_start_string = '', j2_variable_end_string = '', verbose = False git dict status = True, date [ datetime ], short_commit = '3857fed', commit = '3857fedbcab914aeee7119a2bbef03308b4043c2', author = 'Gabriel Konat', tag = '', date_ISO = '2021-08-24 14:41:28 +0200', message = 'Update status', raw = 'commit 3857fedbcab914aeee7119a2bbef03308b4043c2\\nAuthor: Gabriel Konat \\nDate: Tue Aug 24 14:41:28 2021 +0200\\n\\n Update status', root_dir = '/home/runner/work/spoofax-pie/spoofax-pie' context function ( obj, e ) Default mkdocs_macro List the defined variables macros_info function ( ) Test/debug function: list useful documentation on the mkdocs_macro environment. now function ( ) Get the current time (returns a datetime object). Used alone, it provides a timestamp. To get the year use now().year , for the month number now().month , etc. fix_url function ( url, r ) If url is relative, fix it so that it points to the docs diretory. This is necessary because relative links in markdown must be adapted in html ('img/foo.png' => '../img/img.png'). os dict windows = ':fontawesome-brands-windows: Windows', linux = ':fontawesome-brands-linux: Linux', macos = ':fontawesome-brands-apple: macOS' release dict 0.8.0 [ dict ], rel [ dict ], dev [ dict ] filters dict pretty [ function ] filters_builtin dict abs [ builtin_function_or_method ], attr [ function ], batch [ function ], capitalize [ function ], center [ function ], count [ builtin_function_or_method ], d [ function ], default [ function ], dictsort [ function ], e [ builtin_function_or_method ], escape [ builtin_function_or_method ], filesizeformat [ function ], first [ function ], float [ function ], forceescape [ function ], format [ function ], groupby [ function ], indent [ function ], int [ function ], join [ function ], last [ function ], length [ builtin_function_or_method ], list [ function ], lower [ function ], map [ function ], min [ function ], max [ function ], pprint [ function ], random [ function ], reject [ function ], rejectattr [ function ], replace [ function ], reverse [ function ], round [ function ], safe [ function ], select [ function ], selectattr [ function ], slice [ function ], sort [ function ], string [ builtin_function_or_method ], striptags [ function ], sum [ function ], title [ function ], trim [ function ], truncate [ function ], unique [ function ], upper [ function ], urlencode [ function ], urlize [ function ], wordcount [ function ], wordwrap [ function ], xmlattr [ function ], tojson [ function ] navigation Navigation Page(title='Home', url='.') Section(title='Tutorials') Page(title=[blank], url='tutorial/install/') Page(title=[blank], url='tutorial/create_language_project/') Section(title='Reference') Page(title=[blank], url='reference/configuration/') Section(title='Background') Page(title=[blank], url='background/documentation/') Page(title=[blank], url='background/motivation/') Page(title=[blank], url='background/key_ideas/') Page(title=[blank], url='background/status/') Section(title='Releases') Page(title=[blank], url='release/download/') page Page Page(title='Info', url='info/') Config Information \u00b6 Standard MkDocs configuration information. Do not try to modify. e.g. {{ config.docs_dir }} See also the MkDocs documentation on the config object . Variable Type Content config_file_path str '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml' site_name str 'Spoofax 3' nav list [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/configuration.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}] pages NoneType None site_url str '' site_description str 'Spoofax 3 documentation website' site_author NoneType None theme Theme Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.8.11/x64/lib/python3.8/site-packages/material', '/opt/hostedtoolcache/Python/3.8.11/x64/lib/python3.8/site-packages/mkdocs/templates'], static_templates=['sitemap.xml', '404.html'], locale=Locale(language='en', territory=''), language='en', direction=None, features=['navigation.instant', 'navigation.tabs', 'navigation.top'], palette={'primary': 'indigo', 'accent': 'indigo'}, font={'code': 'JetBrains Mono'}, icon=None, favicon='assets/spoofax.png', include_search_page=False, search_index_only=True, logo='assets/spoofax.svg') docs_dir str '/home/runner/work/spoofax-pie/spoofax-pie/docs' site_dir str '/home/runner/work/spoofax-pie/spoofax-pie/site' copyright NoneType None google_analytics NoneType None dev_addr Address Address(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/metaborg/spoofax-pie/' repo_name str 'metaborg/spoofax-pie' edit_uri str 'edit/master/docs/' extra_css list ['extra.css'] extra_javascript list [] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'] mdx_configs dict codehilite [ dict ], toc [ dict ], pymdownx.betterem [ dict ], pymdownx.emoji [ dict ], pymdownx.tasklist [ dict ] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra SubConfig {} plugins PluginCollection search [ SearchPlugin ], macros [ MacrosPlugin ], git-revision-date [ GitRevisionDatePlugin ] Git Information \u00b6 Information available on the last commit and the git repository containing the documentation project: e.g. {{ git.message }} Variable Type Content status bool True date datetime datetime.datetime(2021, 8, 24, 14, 41, 28, tzinfo=tzoffset(None, 7200)) short_commit str '3857fed' commit str '3857fedbcab914aeee7119a2bbef03308b4043c2' author str 'Gabriel Konat' tag str '' date_ISO str '2021-08-24 14:41:28 +0200' message str 'Update status' raw str 'commit 3857fedbcab914aeee7119a2bbef03308b4043c2\\nAuthor: Gabriel Konat \\nDate: Tue Aug 24 14:41:28 2021 +0200\\n\\n Update status' root_dir str '/home/runner/work/spoofax-pie/spoofax-pie' Page Attributes \u00b6 Provided by MkDocs. These attributes change for every page (the attributes shown are for this page). e.g. {{ page.title }} See also the MkDocs documentation on the page object . Variable Type Content file File page [ Page ], src_path = 'info.md', abs_src_path = '/home/runner/work/spoofax-pie/spoofax-pie/docs/info.md', name = 'info', dest_path = 'info/index.html', abs_dest_path = '/home/runner/work/spoofax-pie/spoofax-pie/site/info/index.html', url = 'info/' title str 'Info' parent NoneType None children NoneType None previous_page NoneType None next_page NoneType None _Page__active bool False is_section bool False is_page bool True is_link bool False update_date str '2021-08-24' canonical_url NoneType None abs_url NoneType None edit_url str 'https://github.com/metaborg/spoofax-pie/edit/master/docs/info.md' markdown str '{{ macros_info() }}\\n' content NoneType None toc list [] meta dict To have all titles of all pages, use: {% for page in navigation.pages %} - {{ page.title }} {% endfor% } Plugin Filters \u00b6 These filters are provided as a standard by the macros plugin. Variable Type Content pretty function ( var_list, rows, header, e ) Default mkdocs_macro Prettify a dictionary or object (used for environment documentation, or debugging). Builtin Jinja2 Filters \u00b6 These filters are provided by Jinja2 as a standard. See also the Jinja2 documentation on builtin filters ). Variable Type Content abs builtin_function_or_method Return the absolute value of the argument. attr function ( environment, obj, name, value ) Get an attribute of an object. foo|attr(\"bar\") works like foo.bar just that always an attribute is returned and items are not looked up. batch function ( value, linecount, fill_with, tmp, item ) A filter that batches items. It works pretty much like slice just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example. capitalize function ( s ) Capitalize a value. The first character will be uppercase, all others lowercase. center function ( value, width ) Centers the value in a field of a given width. count builtin_function_or_method Return the number of items in a container. d function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. default function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. dictsort function ( value, case_sensitive, by, reverse, sort_func ) Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. e builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. escape builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. filesizeformat function ( value, binary, bytes, base, prefixes, i, prefix, unit ) Format the value like a 'human-readable' file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to True the binary prefixes are used (Mebi, Gibi). first function ( args, kwargs, b ) Return the first item of a sequence. float function ( value, default ) Convert the value into a floating point number. If the conversion doesn't work it will return 0.0 . You can override this default using the first parameter. forceescape function ( value ) Enforce HTML escaping. This will probably double escape variables. format function ( value, args, kwargs ) Apply the given values to a printf-style _ format string, like string % values . groupby function ( args, kwargs, b ) Group a sequence of objects by an attribute using Python's :func: itertools.groupby . The attribute can use dot notation for nested access, like \"address.city\" . Unlike Python's groupby , the values are sorted first so only one group is returned for each unique value. indent function ( s, width, first, blank, newline, rv, lines ) Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default. int function ( value, default, base ) Convert the value into an integer. If the conversion doesn't work it will return 0 . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. join function ( args, kwargs, b ) Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter. last function ( environment, seq ) Return the last item of a sequence. length builtin_function_or_method Return the number of items in a container. list function ( args, kwargs, b ) Convert the value into a list. If it was a string the returned list will be a list of characters. lower function ( s ) Convert a value to lowercase. map function ( args, kwargs, b ) Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. min function ( environment, value, case_sensitive, attribute ) Return the smallest item from the sequence. max function ( environment, value, case_sensitive, attribute ) Return the largest item from the sequence. pprint function ( value ) Pretty print a variable. Useful for debugging. random function ( context, seq ) Return a random item from the sequence. reject function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. rejectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. replace function ( eval_ctx, s, old, new, count ) Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument count is given, only the first count occurrences are replaced. reverse function ( value, rv ) Reverse the object or return an iterator that iterates over it the other way round. round function ( value, precision, method, func ) Round the number to a given precision. The first parameter specifies the precision (default is 0 ), the second the rounding method. safe function ( value ) Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. select function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. selectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. slice function ( args, kwargs, b ) Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns. sort function ( environment, value, reverse, case_sensitive, attribute, key_func ) Sort an iterable using Python's :func: sorted . string builtin_function_or_method Convert an object to a string if it isn't already. This preserves a :class: Markup string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again. striptags function ( value ) Strip SGML/XML tags and replace adjacent whitespace by one space. sum function ( args, kwargs, b ) Returns the sum of a sequence of numbers plus the value of parameter 'start' (which defaults to 0). When the sequence is empty it returns start. title function ( s ) Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. trim function ( value, chars ) Strip leading and trailing characters, by default whitespace. truncate function ( env, s, length, killwords, end, leeway, result ) Return a truncated copy of the string. The length is specified with the first parameter which defaults to 255 . If the second parameter is true the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( \"...\" ). If you want a different ellipsis sign than \"...\" you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. unique function ( environment, value, case_sensitive, attribute, getter, seen, item, key ) Returns a list of unique items from the given iterable. upper function ( s ) Convert a value to uppercase. urlencode function ( value, items ) Quote data for use in a URL path or query using UTF-8. urlize function ( eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv ) Convert URLs in text into clickable links. wordcount function ( s ) Count the words in that string. wordwrap function ( environment, s, width, break_long_words, wrapstring, break_on_hyphens ) Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately. xmlattr function ( eval_ctx, d, autospace, rv ) Create an SGML/XML attribute string based on the items in a dict. All values that are neither none nor undefined are automatically escaped. tojson function ( eval_ctx, value, indent, policies, dumps, kwargs ) Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.","title":"Info"},{"location":"info/#macros-plugin-environment","text":"","title":"Macros Plugin Environment"},{"location":"info/#general-list","text":"All available variables and filters within the macros plugin: Variable Type Content extra dict config Config config_file_path = '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml', site_name = 'Spoofax 3', nav = [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/configuration.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}], pages [ NoneType ], site_url = '', site_description = 'Spoofax 3 documentation website', site_author [ NoneType ], theme [ Theme ], docs_dir = '/home/runner/work/spoofax-pie/spoofax-pie/docs', site_dir = '/home/runner/work/spoofax-pie/spoofax-pie/site', copyright [ NoneType ], google_analytics [ NoneType ], dev_addr [ Address ], use_directory_urls = True, repo_url = 'https://github.com/metaborg/spoofax-pie/', repo_name = 'metaborg/spoofax-pie', edit_uri = 'edit/master/docs/', extra_css = ['extra.css'], extra_javascript = [], extra_templates = [], markdown_extensions = ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'], mdx_configs [ dict ], strict = False, remote_branch = 'gh-pages', remote_name = 'origin', extra [ SubConfig ], plugins [ PluginCollection ] environment dict system = 'Linux', system_version = '5.4.0-1055-azure', python_version = '3.8.11', mkdocs_version = '1.2.2', macros_plugin_version = '0.5.5', jinja2_version = '3.0.1' plugin Config module_name = 'docs/macro', modules = [], include_dir = '', include_yaml = [], j2_block_start_string = '', j2_block_end_string = '', j2_variable_start_string = '', j2_variable_end_string = '', verbose = False git dict status = True, date [ datetime ], short_commit = '3857fed', commit = '3857fedbcab914aeee7119a2bbef03308b4043c2', author = 'Gabriel Konat', tag = '', date_ISO = '2021-08-24 14:41:28 +0200', message = 'Update status', raw = 'commit 3857fedbcab914aeee7119a2bbef03308b4043c2\\nAuthor: Gabriel Konat \\nDate: Tue Aug 24 14:41:28 2021 +0200\\n\\n Update status', root_dir = '/home/runner/work/spoofax-pie/spoofax-pie' context function ( obj, e ) Default mkdocs_macro List the defined variables macros_info function ( ) Test/debug function: list useful documentation on the mkdocs_macro environment. now function ( ) Get the current time (returns a datetime object). Used alone, it provides a timestamp. To get the year use now().year , for the month number now().month , etc. fix_url function ( url, r ) If url is relative, fix it so that it points to the docs diretory. This is necessary because relative links in markdown must be adapted in html ('img/foo.png' => '../img/img.png'). os dict windows = ':fontawesome-brands-windows: Windows', linux = ':fontawesome-brands-linux: Linux', macos = ':fontawesome-brands-apple: macOS' release dict 0.8.0 [ dict ], rel [ dict ], dev [ dict ] filters dict pretty [ function ] filters_builtin dict abs [ builtin_function_or_method ], attr [ function ], batch [ function ], capitalize [ function ], center [ function ], count [ builtin_function_or_method ], d [ function ], default [ function ], dictsort [ function ], e [ builtin_function_or_method ], escape [ builtin_function_or_method ], filesizeformat [ function ], first [ function ], float [ function ], forceescape [ function ], format [ function ], groupby [ function ], indent [ function ], int [ function ], join [ function ], last [ function ], length [ builtin_function_or_method ], list [ function ], lower [ function ], map [ function ], min [ function ], max [ function ], pprint [ function ], random [ function ], reject [ function ], rejectattr [ function ], replace [ function ], reverse [ function ], round [ function ], safe [ function ], select [ function ], selectattr [ function ], slice [ function ], sort [ function ], string [ builtin_function_or_method ], striptags [ function ], sum [ function ], title [ function ], trim [ function ], truncate [ function ], unique [ function ], upper [ function ], urlencode [ function ], urlize [ function ], wordcount [ function ], wordwrap [ function ], xmlattr [ function ], tojson [ function ] navigation Navigation Page(title='Home', url='.') Section(title='Tutorials') Page(title=[blank], url='tutorial/install/') Page(title=[blank], url='tutorial/create_language_project/') Section(title='Reference') Page(title=[blank], url='reference/configuration/') Section(title='Background') Page(title=[blank], url='background/documentation/') Page(title=[blank], url='background/motivation/') Page(title=[blank], url='background/key_ideas/') Page(title=[blank], url='background/status/') Section(title='Releases') Page(title=[blank], url='release/download/') page Page Page(title='Info', url='info/')","title":"General List"},{"location":"info/#config-information","text":"Standard MkDocs configuration information. Do not try to modify. e.g. {{ config.docs_dir }} See also the MkDocs documentation on the config object . Variable Type Content config_file_path str '/home/runner/work/spoofax-pie/spoofax-pie/mkdocs.yml' site_name str 'Spoofax 3' nav list [{'Home': 'index.md'}, {'Tutorials': ['tutorial/install.md', 'tutorial/create_language_project.md']}, {'Reference': ['reference/configuration.md']}, {'Background': ['background/documentation.md', 'background/motivation.md', 'background/key_ideas.md', 'background/status.md']}, {'Releases': ['release/download.md']}] pages NoneType None site_url str '' site_description str 'Spoofax 3 documentation website' site_author NoneType None theme Theme Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.8.11/x64/lib/python3.8/site-packages/material', '/opt/hostedtoolcache/Python/3.8.11/x64/lib/python3.8/site-packages/mkdocs/templates'], static_templates=['sitemap.xml', '404.html'], locale=Locale(language='en', territory=''), language='en', direction=None, features=['navigation.instant', 'navigation.tabs', 'navigation.top'], palette={'primary': 'indigo', 'accent': 'indigo'}, font={'code': 'JetBrains Mono'}, icon=None, favicon='assets/spoofax.png', include_search_page=False, search_index_only=True, logo='assets/spoofax.svg') docs_dir str '/home/runner/work/spoofax-pie/spoofax-pie/docs' site_dir str '/home/runner/work/spoofax-pie/spoofax-pie/site' copyright NoneType None google_analytics NoneType None dev_addr Address Address(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url str 'https://github.com/metaborg/spoofax-pie/' repo_name str 'metaborg/spoofax-pie' edit_uri str 'edit/master/docs/' extra_css list ['extra.css'] extra_javascript list [] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'abbr', 'admonition', 'attr_list', 'codehilite', 'def_list', 'pymdownx.betterem', 'pymdownx.caret', 'pymdownx.details', 'pymdownx.emoji', 'pymdownx.inlinehilite', 'pymdownx.keys', 'pymdownx.magiclink', 'pymdownx.mark', 'pymdownx.saneheaders', 'pymdownx.smartsymbols', 'pymdownx.snippets', 'pymdownx.superfences', 'pymdownx.tabbed', 'pymdownx.tasklist', 'pymdownx.tilde'] mdx_configs dict codehilite [ dict ], toc [ dict ], pymdownx.betterem [ dict ], pymdownx.emoji [ dict ], pymdownx.tasklist [ dict ] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra SubConfig {} plugins PluginCollection search [ SearchPlugin ], macros [ MacrosPlugin ], git-revision-date [ GitRevisionDatePlugin ]","title":"Config Information"},{"location":"info/#git-information","text":"Information available on the last commit and the git repository containing the documentation project: e.g. {{ git.message }} Variable Type Content status bool True date datetime datetime.datetime(2021, 8, 24, 14, 41, 28, tzinfo=tzoffset(None, 7200)) short_commit str '3857fed' commit str '3857fedbcab914aeee7119a2bbef03308b4043c2' author str 'Gabriel Konat' tag str '' date_ISO str '2021-08-24 14:41:28 +0200' message str 'Update status' raw str 'commit 3857fedbcab914aeee7119a2bbef03308b4043c2\\nAuthor: Gabriel Konat \\nDate: Tue Aug 24 14:41:28 2021 +0200\\n\\n Update status' root_dir str '/home/runner/work/spoofax-pie/spoofax-pie'","title":"Git Information"},{"location":"info/#page-attributes","text":"Provided by MkDocs. These attributes change for every page (the attributes shown are for this page). e.g. {{ page.title }} See also the MkDocs documentation on the page object . Variable Type Content file File page [ Page ], src_path = 'info.md', abs_src_path = '/home/runner/work/spoofax-pie/spoofax-pie/docs/info.md', name = 'info', dest_path = 'info/index.html', abs_dest_path = '/home/runner/work/spoofax-pie/spoofax-pie/site/info/index.html', url = 'info/' title str 'Info' parent NoneType None children NoneType None previous_page NoneType None next_page NoneType None _Page__active bool False is_section bool False is_page bool True is_link bool False update_date str '2021-08-24' canonical_url NoneType None abs_url NoneType None edit_url str 'https://github.com/metaborg/spoofax-pie/edit/master/docs/info.md' markdown str '{{ macros_info() }}\\n' content NoneType None toc list [] meta dict To have all titles of all pages, use: {% for page in navigation.pages %} - {{ page.title }} {% endfor% }","title":"Page Attributes"},{"location":"info/#plugin-filters","text":"These filters are provided as a standard by the macros plugin. Variable Type Content pretty function ( var_list, rows, header, e ) Default mkdocs_macro Prettify a dictionary or object (used for environment documentation, or debugging).","title":"Plugin Filters"},{"location":"info/#builtin-jinja2-filters","text":"These filters are provided by Jinja2 as a standard. See also the Jinja2 documentation on builtin filters ). Variable Type Content abs builtin_function_or_method Return the absolute value of the argument. attr function ( environment, obj, name, value ) Get an attribute of an object. foo|attr(\"bar\") works like foo.bar just that always an attribute is returned and items are not looked up. batch function ( value, linecount, fill_with, tmp, item ) A filter that batches items. It works pretty much like slice just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example. capitalize function ( s ) Capitalize a value. The first character will be uppercase, all others lowercase. center function ( value, width ) Centers the value in a field of a given width. count builtin_function_or_method Return the number of items in a container. d function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. default function ( value, default_value, boolean ) If the value is undefined it will return the passed default value, otherwise the value of the variable. dictsort function ( value, case_sensitive, by, reverse, sort_func ) Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. e builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. escape builtin_function_or_method Replace the characters & , < , > , ' , and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. filesizeformat function ( value, binary, bytes, base, prefixes, i, prefix, unit ) Format the value like a 'human-readable' file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to True the binary prefixes are used (Mebi, Gibi). first function ( args, kwargs, b ) Return the first item of a sequence. float function ( value, default ) Convert the value into a floating point number. If the conversion doesn't work it will return 0.0 . You can override this default using the first parameter. forceescape function ( value ) Enforce HTML escaping. This will probably double escape variables. format function ( value, args, kwargs ) Apply the given values to a printf-style _ format string, like string % values . groupby function ( args, kwargs, b ) Group a sequence of objects by an attribute using Python's :func: itertools.groupby . The attribute can use dot notation for nested access, like \"address.city\" . Unlike Python's groupby , the values are sorted first so only one group is returned for each unique value. indent function ( s, width, first, blank, newline, rv, lines ) Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default. int function ( value, default, base ) Convert the value into an integer. If the conversion doesn't work it will return 0 . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. join function ( args, kwargs, b ) Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter. last function ( environment, seq ) Return the last item of a sequence. length builtin_function_or_method Return the number of items in a container. list function ( args, kwargs, b ) Convert the value into a list. If it was a string the returned list will be a list of characters. lower function ( s ) Convert a value to lowercase. map function ( args, kwargs, b ) Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. min function ( environment, value, case_sensitive, attribute ) Return the smallest item from the sequence. max function ( environment, value, case_sensitive, attribute ) Return the largest item from the sequence. pprint function ( value ) Pretty print a variable. Useful for debugging. random function ( context, seq ) Return a random item from the sequence. reject function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. rejectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. replace function ( eval_ctx, s, old, new, count ) Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument count is given, only the first count occurrences are replaced. reverse function ( value, rv ) Reverse the object or return an iterator that iterates over it the other way round. round function ( value, precision, method, func ) Round the number to a given precision. The first parameter specifies the precision (default is 0 ), the second the rounding method. safe function ( value ) Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. select function ( args, kwargs, b ) Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. selectattr function ( args, kwargs, b ) Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. slice function ( args, kwargs, b ) Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns. sort function ( environment, value, reverse, case_sensitive, attribute, key_func ) Sort an iterable using Python's :func: sorted . string builtin_function_or_method Convert an object to a string if it isn't already. This preserves a :class: Markup string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again. striptags function ( value ) Strip SGML/XML tags and replace adjacent whitespace by one space. sum function ( args, kwargs, b ) Returns the sum of a sequence of numbers plus the value of parameter 'start' (which defaults to 0). When the sequence is empty it returns start. title function ( s ) Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. trim function ( value, chars ) Strip leading and trailing characters, by default whitespace. truncate function ( env, s, length, killwords, end, leeway, result ) Return a truncated copy of the string. The length is specified with the first parameter which defaults to 255 . If the second parameter is true the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( \"...\" ). If you want a different ellipsis sign than \"...\" you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. unique function ( environment, value, case_sensitive, attribute, getter, seen, item, key ) Returns a list of unique items from the given iterable. upper function ( s ) Convert a value to uppercase. urlencode function ( value, items ) Quote data for use in a URL path or query using UTF-8. urlize function ( eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv ) Convert URLs in text into clickable links. wordcount function ( s ) Count the words in that string. wordwrap function ( environment, s, width, break_long_words, wrapstring, break_on_hyphens ) Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately. xmlattr function ( eval_ctx, d, autospace, rv ) Create an SGML/XML attribute string based on the items in a dict. All values that are neither none nor undefined are automatically escaped. tojson function ( eval_ctx, value, indent, policies, dumps, kwargs ) Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.","title":"Builtin Jinja2 Filters"},{"location":"_include/_all/","text":"","title":" all"},{"location":"_include/abbreviation/","text":"","title":"Abbreviation"},{"location":"background/documentation/","text":"Documentation \u00b6 In this section, we explain the documentation technology and how it is structured. Technology \u00b6 This documentation is developed with MkDocs , a fast and simple static site generated that's geared towards building project documentation from Markdown files. MkDocs uses Python-Markdown to process Markdown files, along with PyMdown Extensions . We use the Material for MkDocs theme which provides a clean look, easy customization, and many features for technical documentation. We use the following MkDocs plugins: mkdocs-macros-plugin to enable the use of variables, macros, and filters in Markdown files. mkdocs-git-revision-date-plugin to add a changed date to the footer based on the last time the file was changed in the Git repository. The documentation is automatically built and published on a commit to the master branch of this repository using the GitHub actions workflow at .github/workflows/documentation.yml . Structure \u00b6 The structure of this documentation follows The documentation system where documentation is split into four categories: Tutorials : oriented to learning , enabling newcomers to get started through a lesson , analogous to teaching a child how to cook . How-to guides : oriented to a particular goal , showing how to solve a specific problem through a series of steps , analogous to a recipe in a cookery book . Reference : oriented to information , describing the machinery through dry description , analogous to an encyclopaedia article . Explanation : oriented to understanding , explaining through discursive explanation , analogous to an article on culinary social history .","title":"Documentation"},{"location":"background/documentation/#documentation","text":"In this section, we explain the documentation technology and how it is structured.","title":"Documentation"},{"location":"background/documentation/#technology","text":"This documentation is developed with MkDocs , a fast and simple static site generated that's geared towards building project documentation from Markdown files. MkDocs uses Python-Markdown to process Markdown files, along with PyMdown Extensions . We use the Material for MkDocs theme which provides a clean look, easy customization, and many features for technical documentation. We use the following MkDocs plugins: mkdocs-macros-plugin to enable the use of variables, macros, and filters in Markdown files. mkdocs-git-revision-date-plugin to add a changed date to the footer based on the last time the file was changed in the Git repository. The documentation is automatically built and published on a commit to the master branch of this repository using the GitHub actions workflow at .github/workflows/documentation.yml .","title":"Technology"},{"location":"background/documentation/#structure","text":"The structure of this documentation follows The documentation system where documentation is split into four categories: Tutorials : oriented to learning , enabling newcomers to get started through a lesson , analogous to teaching a child how to cook . How-to guides : oriented to a particular goal , showing how to solve a specific problem through a series of steps , analogous to a recipe in a cookery book . Reference : oriented to information , describing the machinery through dry description , analogous to an encyclopaedia article . Explanation : oriented to understanding , explaining through discursive explanation , analogous to an article on culinary social history .","title":"Structure"},{"location":"background/key_ideas/","text":"Key ideas \u00b6 To solve the problems highlighted in the motivation section, we intend to employ the following key ideas in Spoofax 3. To reduce coupling, Spoofax 3's \"Spoofax Core\" does not depend on any meta-components. Instead, a language implementation depends directly on the meta-components that it requires. For example, the Tiger language implementation depends directly on the JSGLR2 parser, the NaBL2 constraint solver, and the Stratego runtime. To make language pipelines flexible, modular, and incremental, we use an incremental, modular, and expressive build system as the basis for creating pipelines: PIE . Language processing steps such as parsing, styling text, analyzing, checking (to provide inline error messages), running (parts of) a compiler, etc. become PIE task definitions. Tasks, which are instances of these task definitions, can depend on each other, and depend on resources such as files. The PIE runtime efficiently and incrementally executes tasks. Furthermore, task definitions can be shared and used by other language implementations, making language implementations modular. To reduce the tedium of dynamic language loading, we instead choose to do static language loading as the default. A language implementation is just a JAR file that can be put on the classpath and used as a regular Java library. For example, to use the JSGLR2 parser of the Tiger language, we just depend on the Tiger language implementation as we would depend on a regular Java library, create an instance of the TigerParser class, and then use that to parse a string into an AST. We still want to automatically provide integrations with the command-line, build systems such as Gradle, and IDEs such as Eclipse and IntelliJ. Therefore, every language implementation must implement the LanguageInstance interface. Spoofax 3 then provides libraries which take a LanguageInstance object, and integrate it with a platform. For example, spoofax.cli takes a LanguageInstance object and provides a command-line application, and spoofax.eclipse does the same for an Eclipse plugin. Because language implementations are just regular Java libraries, they now require some Java boilerplate. However, we do not want language developers to write this Java boilerplate for standard cases. Therefore, we employ a Spoofax 3 compiler that generates this Java boilerplate. If the language developer is not happy with the implementation, or wants to customize parts, they can manually implement or extend Java classes where needed. It is also possible to not use the Spoofax 3 compiler at all, and manually implement all parts. To enable quick language prototyping, we still support dynamic language loading in environments that support them (e.g., Eclipse and IntelliJ), by dynamically loading the language implementation JAR when changed. For example, when prototyping the Tiger language in Eclipse, if the syntax definition is changed we run the Spoofax 3 compiler to (incrementally) create a new parse table and Java classes, and dynamically (re)load the JAR. To improve the user experience, we use a configuration DSL to configure language specifications and implementations. Thereby configuration is centralized, has domain-specific checking, and editor services such as inline errors and code completion. We also allow changing of defaults (conventions), and persist them to enable renaming. To improve error traceability, errors are reported inline where possible. Errors are traced through PIE pipelines and support origin tracking to easily support error traceability and inline errors for all language implementations. TODO: better builders: non-Stratego commands incremental commands separate commands from how they are executed support command parameters/arguments continuous execution TODO: modular and incremental development of Spoofax 3 itself with Gradle","title":"Key ideas"},{"location":"background/key_ideas/#key-ideas","text":"To solve the problems highlighted in the motivation section, we intend to employ the following key ideas in Spoofax 3. To reduce coupling, Spoofax 3's \"Spoofax Core\" does not depend on any meta-components. Instead, a language implementation depends directly on the meta-components that it requires. For example, the Tiger language implementation depends directly on the JSGLR2 parser, the NaBL2 constraint solver, and the Stratego runtime. To make language pipelines flexible, modular, and incremental, we use an incremental, modular, and expressive build system as the basis for creating pipelines: PIE . Language processing steps such as parsing, styling text, analyzing, checking (to provide inline error messages), running (parts of) a compiler, etc. become PIE task definitions. Tasks, which are instances of these task definitions, can depend on each other, and depend on resources such as files. The PIE runtime efficiently and incrementally executes tasks. Furthermore, task definitions can be shared and used by other language implementations, making language implementations modular. To reduce the tedium of dynamic language loading, we instead choose to do static language loading as the default. A language implementation is just a JAR file that can be put on the classpath and used as a regular Java library. For example, to use the JSGLR2 parser of the Tiger language, we just depend on the Tiger language implementation as we would depend on a regular Java library, create an instance of the TigerParser class, and then use that to parse a string into an AST. We still want to automatically provide integrations with the command-line, build systems such as Gradle, and IDEs such as Eclipse and IntelliJ. Therefore, every language implementation must implement the LanguageInstance interface. Spoofax 3 then provides libraries which take a LanguageInstance object, and integrate it with a platform. For example, spoofax.cli takes a LanguageInstance object and provides a command-line application, and spoofax.eclipse does the same for an Eclipse plugin. Because language implementations are just regular Java libraries, they now require some Java boilerplate. However, we do not want language developers to write this Java boilerplate for standard cases. Therefore, we employ a Spoofax 3 compiler that generates this Java boilerplate. If the language developer is not happy with the implementation, or wants to customize parts, they can manually implement or extend Java classes where needed. It is also possible to not use the Spoofax 3 compiler at all, and manually implement all parts. To enable quick language prototyping, we still support dynamic language loading in environments that support them (e.g., Eclipse and IntelliJ), by dynamically loading the language implementation JAR when changed. For example, when prototyping the Tiger language in Eclipse, if the syntax definition is changed we run the Spoofax 3 compiler to (incrementally) create a new parse table and Java classes, and dynamically (re)load the JAR. To improve the user experience, we use a configuration DSL to configure language specifications and implementations. Thereby configuration is centralized, has domain-specific checking, and editor services such as inline errors and code completion. We also allow changing of defaults (conventions), and persist them to enable renaming. To improve error traceability, errors are reported inline where possible. Errors are traced through PIE pipelines and support origin tracking to easily support error traceability and inline errors for all language implementations. TODO: better builders: non-Stratego commands incremental commands separate commands from how they are executed support command parameters/arguments continuous execution TODO: modular and incremental development of Spoofax 3 itself with Gradle","title":"Key ideas"},{"location":"background/motivation/","text":"Motivation \u00b6 In this section we discuss the motivations for developing Spoofax 3. Architecture \u00b6 The main motivation for developing Spoofax 3 is the monolithic, inflexible, and non-incremental architecture of Spoofax 2: It has an inflexible fixed-function pipeline , where every file of your language is parsed, analyzed, and transformed. This works fine, and can even be incremental when the files of your language can be separately compiled. However, this is often not the case. Languages should be able to define their own incremental pipelines with minimal effort. Those pipelines should be modular and flexible, enabling usage in a wide range applications such as command-line interfaces, build systems, code editors, and IDEs. It is monolithic for language users (i.e., the users of your programming language that you have developed with Spoofax), as every language developed with Spoofax 2 depends on Spoofax Core, which in turn depends on all meta-components: JSGLR1 and 2, NaBL+TS index and task engine, NaBL2 & Statix solver, dynsem interpreter, Stratego runtime, config parsing libraries, etc. A language should only require the meta-components that it uses. It is monolithic for meta-component developers (e.g., the developers of the language workbench, or researchers experimenting with new meta-tools or meta-languages). New meta-components need to be tightly integrated into Spoofax Core, requiring time-consuming changes and introducing increased coupling. We should develop meta-components in separation, and loosely couple/integrate them (as much as possible). The build of Spoofax 2 itself is monolithic and non-incremental, as all its components are compiled in one huge non-incremental build, massively increasing iteration time during development. The build must be incremental, and components should be separated where possible to reduce coupling, decreasing iteration times. Language loading \u00b6 Furthermore, Spoofax 2 only support dynamic loading of languages , where a language can be (re)loaded into the running environment. This is very useful during language development, as it enables fast prototyping. However, when we want to statically load the language, we still need to perform the dynamic loading ritual: somehow include the language archive in your application, and then load it at runtime. This hurts startup time, is not supported on some platforms (e.g., Graal native image), and is tedious. We should support both static and dynamic loading (where possible). Error tracing \u00b6 Some errors are not being traced back to their source. For example, many errors in configuration only show up during build time (in the console, which may be hidden) and are not traced back to the configuration file. This confuses users, and may get stuck on simple things, which then require help from us. Errors, warnings, and informational messages should be traced back to their source, and shown inline at the source in IDE environments, or shown as a list of messages with origin information on the command-line. When there are errors, execution should continue in certain instances (e.g., parse error should recover and try to do analysis), but should not in others (e.g., error from static analysis should prevent execution since it could crash). Configuration \u00b6 Another issue is the scattered configuration in language specifications, which is spread over many different places: metaborg.yaml editor/*.esv dynsem.properties In meta-languages files. For example, template options in SDF3. pom.xml .mvn/extensions.xml Finding the right configuration option in these files, and keeping them in sync, is tedious. Furthermore, while most configuration is documented on our website, looking that up still causes a cognitive gap. We should consolidate configuration that belongs together, and not have any duplicate configuration that needs to be kept in sync. Configuration should be supported with editor services such as inline errors and code completion, if possible. Moreover, some parts of a language specification are configured by convention, and these conventions cannot be changed. For example, the main SDF3 file is always assumed to be syntax/<language-name>.sdf3 . When the language name is changed, but we forget to change the name of this main file, no parse table is built. Configuration conventions should be changeable, and defaults should be persisted to ensure that renamings do not break things. Summary of Problems \u00b6 To summarize, Spoofax 2 suffers from the following problems that form the motivation for Spoofax 3: Monolithic, inflexible, and non-incremental architecture causing: Inflexible and slow language processing due to non-incremental fixed-function pipeline Coupling in Spoofax Core: every language depends on Spoofax Core, and Spoofax Core depends on all meta-components Slow iteration times when developing Spoofax 2 due to its monolithic and non-incremental build Tedious to use languages due to dynamic language loading Confusing (end-)user experience due to: Bad error traceability Scattered configuration Non-incremental configuration (restarts required to update configuration)","title":"Motivation"},{"location":"background/motivation/#motivation","text":"In this section we discuss the motivations for developing Spoofax 3.","title":"Motivation"},{"location":"background/motivation/#architecture","text":"The main motivation for developing Spoofax 3 is the monolithic, inflexible, and non-incremental architecture of Spoofax 2: It has an inflexible fixed-function pipeline , where every file of your language is parsed, analyzed, and transformed. This works fine, and can even be incremental when the files of your language can be separately compiled. However, this is often not the case. Languages should be able to define their own incremental pipelines with minimal effort. Those pipelines should be modular and flexible, enabling usage in a wide range applications such as command-line interfaces, build systems, code editors, and IDEs. It is monolithic for language users (i.e., the users of your programming language that you have developed with Spoofax), as every language developed with Spoofax 2 depends on Spoofax Core, which in turn depends on all meta-components: JSGLR1 and 2, NaBL+TS index and task engine, NaBL2 & Statix solver, dynsem interpreter, Stratego runtime, config parsing libraries, etc. A language should only require the meta-components that it uses. It is monolithic for meta-component developers (e.g., the developers of the language workbench, or researchers experimenting with new meta-tools or meta-languages). New meta-components need to be tightly integrated into Spoofax Core, requiring time-consuming changes and introducing increased coupling. We should develop meta-components in separation, and loosely couple/integrate them (as much as possible). The build of Spoofax 2 itself is monolithic and non-incremental, as all its components are compiled in one huge non-incremental build, massively increasing iteration time during development. The build must be incremental, and components should be separated where possible to reduce coupling, decreasing iteration times.","title":"Architecture"},{"location":"background/motivation/#language-loading","text":"Furthermore, Spoofax 2 only support dynamic loading of languages , where a language can be (re)loaded into the running environment. This is very useful during language development, as it enables fast prototyping. However, when we want to statically load the language, we still need to perform the dynamic loading ritual: somehow include the language archive in your application, and then load it at runtime. This hurts startup time, is not supported on some platforms (e.g., Graal native image), and is tedious. We should support both static and dynamic loading (where possible).","title":"Language loading"},{"location":"background/motivation/#error-tracing","text":"Some errors are not being traced back to their source. For example, many errors in configuration only show up during build time (in the console, which may be hidden) and are not traced back to the configuration file. This confuses users, and may get stuck on simple things, which then require help from us. Errors, warnings, and informational messages should be traced back to their source, and shown inline at the source in IDE environments, or shown as a list of messages with origin information on the command-line. When there are errors, execution should continue in certain instances (e.g., parse error should recover and try to do analysis), but should not in others (e.g., error from static analysis should prevent execution since it could crash).","title":"Error tracing"},{"location":"background/motivation/#configuration","text":"Another issue is the scattered configuration in language specifications, which is spread over many different places: metaborg.yaml editor/*.esv dynsem.properties In meta-languages files. For example, template options in SDF3. pom.xml .mvn/extensions.xml Finding the right configuration option in these files, and keeping them in sync, is tedious. Furthermore, while most configuration is documented on our website, looking that up still causes a cognitive gap. We should consolidate configuration that belongs together, and not have any duplicate configuration that needs to be kept in sync. Configuration should be supported with editor services such as inline errors and code completion, if possible. Moreover, some parts of a language specification are configured by convention, and these conventions cannot be changed. For example, the main SDF3 file is always assumed to be syntax/<language-name>.sdf3 . When the language name is changed, but we forget to change the name of this main file, no parse table is built. Configuration conventions should be changeable, and defaults should be persisted to ensure that renamings do not break things.","title":"Configuration"},{"location":"background/motivation/#summary-of-problems","text":"To summarize, Spoofax 2 suffers from the following problems that form the motivation for Spoofax 3: Monolithic, inflexible, and non-incremental architecture causing: Inflexible and slow language processing due to non-incremental fixed-function pipeline Coupling in Spoofax Core: every language depends on Spoofax Core, and Spoofax Core depends on all meta-components Slow iteration times when developing Spoofax 2 due to its monolithic and non-incremental build Tedious to use languages due to dynamic language loading Confusing (end-)user experience due to: Bad error traceability Scattered configuration Non-incremental configuration (restarts required to update configuration)","title":"Summary of Problems"},{"location":"background/status/","text":"Current Status \u00b6 We have stated our key ideas, but since Spoofax 3 is still under heavy development, they have not all been implemented yet. We now discuss the current status of Spoofax 3 by summarizing the key ideas and whether they has been implemented, along with any comments. Decoupling : Spoofax Core not depend on any meta-components. Language implementations instead depend on the meta-components they require. Flexible, modular and incremental pipelines : Use PIE . Static loading : Use static loading by default, making language implementation plain JAR files, which are easy to use in the Java ecosystem. LanguageInstance interface : Language implementations must implement the LanguageInstance interface, which a platform library uses to integrate a language with the platform. An initial version of the LanguageInstance interface exists, but this interface is not yet stable and will receive many new features. Currently, this interface contains features pertaining both command-line platforms and IDE/code editor platforms. These may be split up in the future. Generate Java boilerplate : Generate the Java boilerplate that Spoofax 3 now requires due to the LanguageInstance interface and language implementations being plain JAR files. Configuration for Spoofax 3 language implementations based on Spoofax 2 language definitions is provided through a Gradle build script, which is verbose. Quick language prototyping : Support dynamic language loading in environments that support this, to enable quick language prototyping. Configuration DSL : Use a configuration DSL to improve the developer/user experience. Error origin tracking : Perform origin tracking and propagation on errors to improve the developer/user experience. Not all PIE tasks trace errors, and some errors do not have location information yet. Commands : More flexible and incremental version of \"builders\" from Spoofax 2. Non-Stratego commands : Commands execute PIE tasks, which execute Java code. Incremental commands : Commands are incremental because they execute PIE tasks. Separate commands from how they are executed : Commands can be bound to IDE/editor menus, command-line commands, or to resource changes. Command parameters/arguments : Commands can specify parameters, which must be provided as arguments when executed. Modular and incremental development : Use Gradle (instead of Maven) to build Spoofax 3, which increases modularity and provides incremental builds for faster iteration times. Certain changes to core components may trigger long rebuilds, as a lot of projects (indirectly) depend on these core components and require recompilation. Certain changes trigger recompilation of Gradle plugins which are required by the rest of the build. This may cause a long configuration phase which is not parallelized. Our Gradle plugins do not support the Gradle build cache yet. Our Gradle plugins do not support the configuration cache yet. Sometimes multiple imports into IntelliJ are required to have it recognize all dependencies. Furthermore, we now discuss the status of features that were not new key ideas. Language builds Meta-language bootstrapping Bootstrapping requires implementation of the meta-languages in Spoofax 3, which we have not done yet. Meta-tools Syntax specification SDF3 Parsing JSGLR1 JSGLR2 Incremental parsing (but incompatible with recovery) Styling specification ESV (syntax-based) Semantic analysis NaBL2 Only supported for Spoofax 2-based language definitions Statix Statix signature generation based on SDF3 specification FlowSpec Stratego 2 Transformation (compilation) Stratego 2 Testing SPT Not all expectations have been ported over yet Editor services Syntax-based styling Inline error/warning/note messages Reference resolution Hover tooltips Code completion Syntactic Semantic (i.e., based on static semantics) Outline Platforms Command-line Eclipse Concurrency/parallelism is mostly ignored. Therefore, things may run concurrently that are not suppose to which cause data races and crashes. Several editor services and other conveniences are still missing or work in progress. IntelliJ A very minimal IntelliJ plugin for your language is provided, currently only supporting syntax highlighting and inline parse errors. Gradle Maven REPL The following features are being prototyped/experimented with Spoofax 3: Multi-lingual semantic analysis with Statix (Aron Zwaan) Semantic code completion based on Statix specification (Daniel Pelsmaeker) The following features will most likely not be supported: Analysis with NaBL/TS","title":"Current Status"},{"location":"background/status/#current-status","text":"We have stated our key ideas, but since Spoofax 3 is still under heavy development, they have not all been implemented yet. We now discuss the current status of Spoofax 3 by summarizing the key ideas and whether they has been implemented, along with any comments. Decoupling : Spoofax Core not depend on any meta-components. Language implementations instead depend on the meta-components they require. Flexible, modular and incremental pipelines : Use PIE . Static loading : Use static loading by default, making language implementation plain JAR files, which are easy to use in the Java ecosystem. LanguageInstance interface : Language implementations must implement the LanguageInstance interface, which a platform library uses to integrate a language with the platform. An initial version of the LanguageInstance interface exists, but this interface is not yet stable and will receive many new features. Currently, this interface contains features pertaining both command-line platforms and IDE/code editor platforms. These may be split up in the future. Generate Java boilerplate : Generate the Java boilerplate that Spoofax 3 now requires due to the LanguageInstance interface and language implementations being plain JAR files. Configuration for Spoofax 3 language implementations based on Spoofax 2 language definitions is provided through a Gradle build script, which is verbose. Quick language prototyping : Support dynamic language loading in environments that support this, to enable quick language prototyping. Configuration DSL : Use a configuration DSL to improve the developer/user experience. Error origin tracking : Perform origin tracking and propagation on errors to improve the developer/user experience. Not all PIE tasks trace errors, and some errors do not have location information yet. Commands : More flexible and incremental version of \"builders\" from Spoofax 2. Non-Stratego commands : Commands execute PIE tasks, which execute Java code. Incremental commands : Commands are incremental because they execute PIE tasks. Separate commands from how they are executed : Commands can be bound to IDE/editor menus, command-line commands, or to resource changes. Command parameters/arguments : Commands can specify parameters, which must be provided as arguments when executed. Modular and incremental development : Use Gradle (instead of Maven) to build Spoofax 3, which increases modularity and provides incremental builds for faster iteration times. Certain changes to core components may trigger long rebuilds, as a lot of projects (indirectly) depend on these core components and require recompilation. Certain changes trigger recompilation of Gradle plugins which are required by the rest of the build. This may cause a long configuration phase which is not parallelized. Our Gradle plugins do not support the Gradle build cache yet. Our Gradle plugins do not support the configuration cache yet. Sometimes multiple imports into IntelliJ are required to have it recognize all dependencies. Furthermore, we now discuss the status of features that were not new key ideas. Language builds Meta-language bootstrapping Bootstrapping requires implementation of the meta-languages in Spoofax 3, which we have not done yet. Meta-tools Syntax specification SDF3 Parsing JSGLR1 JSGLR2 Incremental parsing (but incompatible with recovery) Styling specification ESV (syntax-based) Semantic analysis NaBL2 Only supported for Spoofax 2-based language definitions Statix Statix signature generation based on SDF3 specification FlowSpec Stratego 2 Transformation (compilation) Stratego 2 Testing SPT Not all expectations have been ported over yet Editor services Syntax-based styling Inline error/warning/note messages Reference resolution Hover tooltips Code completion Syntactic Semantic (i.e., based on static semantics) Outline Platforms Command-line Eclipse Concurrency/parallelism is mostly ignored. Therefore, things may run concurrently that are not suppose to which cause data races and crashes. Several editor services and other conveniences are still missing or work in progress. IntelliJ A very minimal IntelliJ plugin for your language is provided, currently only supporting syntax highlighting and inline parse errors. Gradle Maven REPL The following features are being prototyped/experimented with Spoofax 3: Multi-lingual semantic analysis with Statix (Aron Zwaan) Semantic code completion based on Statix specification (Daniel Pelsmaeker) The following features will most likely not be supported: Analysis with NaBL/TS","title":"Current Status"},{"location":"reference/anatomy_language_implementation/","text":"Anatomy of a language implementation \u00b6 In this section we give a high-level overview of what a Spoofax 3 language implementation is, dive into details, and explain how such a implementation can be manually written or completely generated from a high-level language specification Overview \u00b6 In essence, a language implementation in Spoofax 3 is nothing more than a standard Java library (e.g., a JAR file) with Java classes implementing or delegating to the various functionalities of the language such as parsing and transformations, as well as bundled resources such as a parse table which is loaded and interpreted at runtime. Therefore, Spoofax 3 language implementations are very easy to use in the Java ecosystem by just distributing the JAR file of the language, or by publishing/consuming it as a library with a build system such as Gradle. Furthermore, since no classloading or class generation is used, GraalVM native image can be used to ahead-of-time compile your language implementation into native code which does not require a JVM at all, and significantly reduces the startup time of your language. Diving deeper, a language implementation is actually split into three parts: a language project that contains the base functionality of the language, an adapter project that adapts the language project to the interface of Spoofax, and platform projects that plug the adapter project into various other platforms such as a command-line interface (CLI) and Eclipse plugin (TODO: more details on supported platforms in a separate section). We will first explain these projects and why this separation was chosen. TODO: diagram? Language Project \u00b6 A language project contains the base functionality of a language, such as a parser, syntax highlighter, analyzer, and compiler for the language. Such a project is unstructured : it does not have to adhere to any interface or data format. Therefore, it may use any tooling, libraries, and data structures to implement the base functionality. This facilitates integration of existing tools and minimal dependencies. A language project is just a Java library and can thus be used in a standalone fashion. However, there is no glue between base functionality, requiring manual implementation of a parse-analyze-compile pipeline for example. Furthermore, because the project is unstructured, we cannot provide any integration with other platforms such as a CLI and Eclipse plugin. Therefore, using a language project as a standalone library is a bit of a niche use case for when minimal dependencies or full control is absolutely necessary. Because it is such a niche use case, the default in Spoofax 3 is to merge it together with the adapter project. In essence, an adapter project adapts a language project to Spoofax 3. To understand why, we first explain the high-level architecture of Spoofax 3. Spoofax 3 architecture overview \u00b6 Spoofax 3 provides a general interface for language implementations: LanguageInstance , which is used by platforms to automatically plug languages into their platform. For example, LanguageInstance has functionality for syntax highlighting , which when given a resource of the language, returns a syntax highlighting for that resource. (TODO: more details on the functionality in LanguageInstance in a separate section) Furthermore, Spoofax 3 uses PIE ; a framework for building incremental pipelines, build systems, and compilers; to incrementalize the language implementation. Instead of directly computing the syntax highlighting for a resource, we create a task that returns the syntax highlighting when demanded, with PIE taking care of whether it should recompute the syntax highlighting because the resource (or the syntax highlighting implementation) changed, or if it can just be returned from a cache. (TODO: more details on PIE in a separate section) A platform such as Eclipse or IntelliJ can then take a LanguageInstance implementation, demand the syntax highlighting task, and show the result it in the editor for your language. Therefore, any language that implements LanguageInstance can get syntax highlighting in Eclipse, IntelliJ, and any other supported platforms for free, with PIE taking care of coarse-grained incrementalization. To receive the benefits of Spoofax 3, the adapter project must thus be implemented for your language. Adapter Project \u00b6 An adapter project implements Spoofax 3's LanguageInstance using the language project. This requires glue code between the unstructured language project and the structured LanguageInstance interface. For example, you would need to convert the data structure that the syntax highlighter of your language returns, to one that Spoofax 3 understands: the Styling class. Furthermore, because Spoofax 3 uses PIE, we also need to implement a PIE task definition that implements the (re)computing of syntax highlighting, as well as mark all dependencies that should cause the syntax highlighting to be recomputed. We also need to be able to instantiate your implementation of LanguageInstance . In case this is non-trivial, the recommended practice is to use dependency injection to achieve proper separation of concerns. A dependency injection framework such as Dagger is recommended (we use it extensively in Spoofax 3) because it catches dependency injection errors at compile-time, and does not require runtime class loading or generation. This may sound like you would need to write a lot of boilerplate. However, we provide a compiler that generates all this boilerplate for you. It is only necessary to write this boilerplate if you are integrating existing tooling. Even then, the compiler can generate some of the boilerplate for you. More details on the compiler can be found in the developing language implementations section. Platform Projects \u00b6 TODO: every language-platform combination is a separate project to support ahead-of-time compilation, static loading, and customization of the platform project. CLI: can be ahead-of-time compiled with GraalVM native image to create a native Windows/macOS/Linux CLI for your language Eclipse/IntelliJ: statically loaded plugin that can be deployed with Eclipse/IntelliJ, and can be fully customized. Developing Language Implementations \u00b6 So far we have talked about what a language implementation is, but not yet how one is developed, which we will dive into now. Language implementations are by default fully generated from a high-level language specification using the Spoofax 3 compiler, thereby supporting iterative language development with low boilerplate. However, it is possible implement parts of or even the entire language/adapter project by hand, facilitating the integration of existing tools and languages. TODO: dynamic loading","title":"Anatomy of a language implementation"},{"location":"reference/anatomy_language_implementation/#anatomy-of-a-language-implementation","text":"In this section we give a high-level overview of what a Spoofax 3 language implementation is, dive into details, and explain how such a implementation can be manually written or completely generated from a high-level language specification","title":"Anatomy of a language implementation"},{"location":"reference/anatomy_language_implementation/#overview","text":"In essence, a language implementation in Spoofax 3 is nothing more than a standard Java library (e.g., a JAR file) with Java classes implementing or delegating to the various functionalities of the language such as parsing and transformations, as well as bundled resources such as a parse table which is loaded and interpreted at runtime. Therefore, Spoofax 3 language implementations are very easy to use in the Java ecosystem by just distributing the JAR file of the language, or by publishing/consuming it as a library with a build system such as Gradle. Furthermore, since no classloading or class generation is used, GraalVM native image can be used to ahead-of-time compile your language implementation into native code which does not require a JVM at all, and significantly reduces the startup time of your language. Diving deeper, a language implementation is actually split into three parts: a language project that contains the base functionality of the language, an adapter project that adapts the language project to the interface of Spoofax, and platform projects that plug the adapter project into various other platforms such as a command-line interface (CLI) and Eclipse plugin (TODO: more details on supported platforms in a separate section). We will first explain these projects and why this separation was chosen. TODO: diagram?","title":"Overview"},{"location":"reference/anatomy_language_implementation/#language-project","text":"A language project contains the base functionality of a language, such as a parser, syntax highlighter, analyzer, and compiler for the language. Such a project is unstructured : it does not have to adhere to any interface or data format. Therefore, it may use any tooling, libraries, and data structures to implement the base functionality. This facilitates integration of existing tools and minimal dependencies. A language project is just a Java library and can thus be used in a standalone fashion. However, there is no glue between base functionality, requiring manual implementation of a parse-analyze-compile pipeline for example. Furthermore, because the project is unstructured, we cannot provide any integration with other platforms such as a CLI and Eclipse plugin. Therefore, using a language project as a standalone library is a bit of a niche use case for when minimal dependencies or full control is absolutely necessary. Because it is such a niche use case, the default in Spoofax 3 is to merge it together with the adapter project. In essence, an adapter project adapts a language project to Spoofax 3. To understand why, we first explain the high-level architecture of Spoofax 3.","title":"Language Project"},{"location":"reference/anatomy_language_implementation/#spoofax-3-architecture-overview","text":"Spoofax 3 provides a general interface for language implementations: LanguageInstance , which is used by platforms to automatically plug languages into their platform. For example, LanguageInstance has functionality for syntax highlighting , which when given a resource of the language, returns a syntax highlighting for that resource. (TODO: more details on the functionality in LanguageInstance in a separate section) Furthermore, Spoofax 3 uses PIE ; a framework for building incremental pipelines, build systems, and compilers; to incrementalize the language implementation. Instead of directly computing the syntax highlighting for a resource, we create a task that returns the syntax highlighting when demanded, with PIE taking care of whether it should recompute the syntax highlighting because the resource (or the syntax highlighting implementation) changed, or if it can just be returned from a cache. (TODO: more details on PIE in a separate section) A platform such as Eclipse or IntelliJ can then take a LanguageInstance implementation, demand the syntax highlighting task, and show the result it in the editor for your language. Therefore, any language that implements LanguageInstance can get syntax highlighting in Eclipse, IntelliJ, and any other supported platforms for free, with PIE taking care of coarse-grained incrementalization. To receive the benefits of Spoofax 3, the adapter project must thus be implemented for your language.","title":"Spoofax 3 architecture overview"},{"location":"reference/anatomy_language_implementation/#adapter-project","text":"An adapter project implements Spoofax 3's LanguageInstance using the language project. This requires glue code between the unstructured language project and the structured LanguageInstance interface. For example, you would need to convert the data structure that the syntax highlighter of your language returns, to one that Spoofax 3 understands: the Styling class. Furthermore, because Spoofax 3 uses PIE, we also need to implement a PIE task definition that implements the (re)computing of syntax highlighting, as well as mark all dependencies that should cause the syntax highlighting to be recomputed. We also need to be able to instantiate your implementation of LanguageInstance . In case this is non-trivial, the recommended practice is to use dependency injection to achieve proper separation of concerns. A dependency injection framework such as Dagger is recommended (we use it extensively in Spoofax 3) because it catches dependency injection errors at compile-time, and does not require runtime class loading or generation. This may sound like you would need to write a lot of boilerplate. However, we provide a compiler that generates all this boilerplate for you. It is only necessary to write this boilerplate if you are integrating existing tooling. Even then, the compiler can generate some of the boilerplate for you. More details on the compiler can be found in the developing language implementations section.","title":"Adapter Project"},{"location":"reference/anatomy_language_implementation/#platform-projects","text":"TODO: every language-platform combination is a separate project to support ahead-of-time compilation, static loading, and customization of the platform project. CLI: can be ahead-of-time compiled with GraalVM native image to create a native Windows/macOS/Linux CLI for your language Eclipse/IntelliJ: statically loaded plugin that can be deployed with Eclipse/IntelliJ, and can be fully customized.","title":"Platform Projects"},{"location":"reference/anatomy_language_implementation/#developing-language-implementations","text":"So far we have talked about what a language implementation is, but not yet how one is developed, which we will dive into now. Language implementations are by default fully generated from a high-level language specification using the Spoofax 3 compiler, thereby supporting iterative language development with low boilerplate. However, it is possible implement parts of or even the entire language/adapter project by hand, facilitating the integration of existing tools and languages. TODO: dynamic loading","title":"Developing Language Implementations"},{"location":"reference/configuration/","text":"Configuration \u00b6 The main entry point of a language definition is the spoofaxc.cfg (Spoofax compiler configuration) file, written in the CFG language. The goal of this config file is to configure basic options, enable/disable features, point to main source files of meta-languages, to add/override behaviour, and to serve as an anchor on the filesystem. The directory that the spoofaxc.cfg file is in is called the \"root directory\" of the language definition, and any relative paths are resolved relative to that directory. The CFG language has domain-specific syntax for configuring language definitions. However, the syntax follows these conventions: Options are assigned a value with $Option = $Expression . Unless specified otherwise, options may only be given once. Sections $Section { ... } may enable features and group options. Lists $List [ ..., ... ] indicate an option/section may be given 0-many times. Let bindings let $Name = $Expression can be used to give values a name that can be (re-)used in the rest of the configuration file. If something in the documentation is unclear, the CFG language definition can be found here . In its most basic form, the spoofaxc.cfg file for a language named Calc looks as follows: name = \"Calc\" which assigns the string \"Calc\" to the name option. A more interesting example configures more options and enables syntax definition: name = \"Calc\" java-class-id-prefix = java Calc file-extension = \"calc\" sdf3 {} parser { default-start-symbol = sort Program } Here, java Calc is assigned to the java-class-id-prefix option. The sdf3 {} section from the example is empty, but is used to enable the SDF3 meta-language. The parser section enables generation of a parser, and also sets the default start symbol to use to sort Program . Literals \u00b6 Literals are expressions that are usually directly assigned to options, or bound to a name with let bindings. CFG has the following literals: Syntax Example(s) Type (true|false) true false Boolean \"(~[\\\"\\$\\n\\r\\\\] | \\\\~[\\n\\r])*\" \"foo\" \"bar\" String (./|/)~[\\n\\r\\,\\;\\]\\)\\}\\ ]* ./relative/file /absolute/file Filesystem path $JavaIdChars Java foo Java identifier $JavaQIdLit Java foo.bar.Baz Qualified Java identifier task-def $JavaQIdLit task-def foo.bar.Baz Qualified Java identifier that represents a task definition sort [a-zA-Z0-9\\-\\_\\$]+ sort Start SDF3 sort identifier strategy [a-zA-Z0-9\\-\\_\\$]+ strategy Start Stratego strategy identifier With the following syntax non-terminals: Name Syntax JavaIdChars [a-zA-Z\\_\\$][a-zA-Z0-9\\_\\$]* JavaQIdLit $JavaIdChars(\\.$JavaIdChars)* For Java, SDF3 sort, and Stratego strategy identifiers, the corresponding keywords of those languages are rejected as identifiers. Let bindings \u00b6 Let bindings of the form let $Name = $Expression bind a name to an expression, for example: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst let showParsedAstCommand = command-def { task-def = showParsedAst ... } editor-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand ... } ] ] creates a binding from name showParsedAst to task-def mb.helloworld.task.HelloWorldShowParsedAst , which we then pass to the task-def option in command-def . The command in turn is bound to showParsedAstCommand , assigned to the command-def option in a command-action section. Top-level options \u00b6 The following top-level options exist: Syntax Required? Description Type group = $Expression no Group identifier of the language, used as the group / groupId in the Java ecosystem. Defaults to org.metaborg . String id = $Expression no Artifact identifier of the language, used as the name / artifactId in the Java ecosystem. Defaults to the name of the language uncapitalized. String name = $Expression yes Name of the language. String version = $Expression no Version of the language, used as the version in the Java ecosystem. Defaults to 0.1.0 . String file-extension = $Expression no File extension of the language. May be given multiple times. Defaults to the name of the language transformed to fit in 3 characters. String java-package-id-prefix = $Expression no The prefix to add before all package identifiers in Java source files. Defaults to mb.$Name where $Name is transformed to be a valid package identifier. Qualified Java identifier java-class-id-prefix = $Expression no The prefix to add before all Java classes. Defaults to the name of the language transformed to be a valid class identifier. Java identifier source-directory = $Expression no Path relative to the root directory that has the sources of the language definition. Defaults to src . Path build-directory = $Expression no Path relative to the root directory that has the generated sources and build outputs when building the language definition. Defaults to build . Path Commands \u00b6 Commands are sections that are also expressions, typically assigned to a name with a let binding, with the following form: let $Name = command-def { $CommandOption* } The following options are available in a command: Syntax Required? Description Type task-def = $Expression yes The task definition that the command will execute. Qualified Java identifier that represents a task definition, or qualified Java identifier type = $Expression no The fully qualified Java type we want this command to be generated as. Can be omitted to generate a type based on the name of the task definition. Qualified Java identifier display-name = $Expression yes The display name of the command. String description = $Expression no The optional description of the command. String supported-execution-types = [($ExecutionType ,)*] no The optional supported execution types of the command. Defaults to [Once, Continuous] . n/a args-type = $Expression no The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. Qualified Java identifier parameters = [ $Parameter* ] yes The description of the parameters of the command n/a The following ExecutionType s are supported: Once indicates a that this command supports being executed as a one-shot command. Continuous indicates that this command supports being executed every time the source file changes. A $Parameter has the form $Identifier = parameter { $ParameterOptions } with the following options: Syntax Required? Description Type type = $Expression yes The fully qualified Java of the type of the parameter. This must match the type of the parameter inside the args-type of the command. Qualified Java identifier required = $Expression no Whether the parameter is required. Defaults to true . Boolean converter-type = $Expression no The argument converter for this parameter, which can convert a String value to the type of this parameter. Must implement the ArgConverter interface. Qualified Java identifier argument-providers = [($ArgumentProvider ,)*] no Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. If no arguments can be provided, and the argument is required, then the argument must be provided by the user that executes the command, or executing the command will fail. n/a The following ArgumentProvider s are supported: Value($Expression) provides a default value given by the expression. The expression must match the type of the parameter, even though this is not currently checked. Context($CommandContext) attempts to infer the argument by context. The following CommandContext s are supported: Directory : attempt to infer a ResourcePath to an existing directory. For example, when right-clicking a directory in an IDE to execute a command on that directory. File : attempt to infer a ResourcePath to an existing file. For example, when right-clicking a file in an IDE to execute a command on that directory, or when executing a command in an editor for a file. HierarchicalResource : attempt to infer a ResourcePath to a hierarchical resource. A hierarchical resource is a resource that belongs to a (tree) hierarchy, such as a file or directory on the local filesystem. Use this when the command relies on the resource being in a filesystem, but does not care whether it is a directory or a file. ReadableResource : attempt to infer a ResourceKey to a readable resource. This is more general than File , as we only ask for a resource that can be read, not one that belongs to a (local) filesystem. Use this when the command does not rely on the resource being in a filesystem. Region : attempt to infer a Region in a source file. Inference succeeds when the context has a selection of size 1 or larger. For example, when executing a command in an editor that has a selection, the region will be that selection. Offset : attempt to infer an int representing an offset in a source file. Inference succeeds when the context has a cursor offset (i.e., a selection of size 0 or larger). For example, when executing a command in an editor, the offset will be the offset to the cursor in the editor. EnclosingContext($EnclosingCommandContext) attempts to infer the argument by the enclosing context. The following EnclosingCommandContext s are supported: Project : attempt to infer a ResourcePath to the enclosing project. For example, when executing a command in an IDE on a file, directory, or editor for a file, that belongs to a project. Or when executing a command in a CLI, the directory will be the current working directory. Directory : attempt to infer a ResourcePath to the enclosing directory. For example, when executing a command in the context of a file, directory, or editor for a file, the directory will be the parent of that file/directory. Here is an example of a command that shows the parsed AST by taking one file argument that is inferred from context: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand task-def = showParsedAst args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args display-name = \"Show parsed AST\" description = \"Shows the parsed AST\" supported-execution-types = [Once, Continuous] parameters = [ file = parameter { type = java mb.resource.ResourceKey required = true argument-providers = [Context(ResourceKey)] } ] } Menu items \u00b6 Menu items take the form of: a separator representing a horizontal line in a menu used to separate groups of menu items. a menu $Expression [ $MenuItem* ] representing a (nested) menu with a display name defined by the expression which must be a string, and a list of nested menu items. a command-action { $CommandActionOption* } representing an action that executes a command when a user clicks on it. A command action has the following options: Syntax Required? Description Type command-def = $Expression yes The command to execute. Command or qualified Java identifier execution-type = $ExecutionType yes How the command should be executed. n/a required-resource-types = [($ResourceType ,)*] no On which kinds of resources this menu item will be shown on resource context menus. Defaults to empty. If empty, it will not be hidden based on resources. n/a required-enclosing-resource-types = [($EnclosingResourceType ,)*] no On which kinds of enclosing resources this menu item will be shown on resource context menus. Defaults to empty. If empty, it will not be hidden based on enclosing resource. n/a required-editor-file-types = [($EditorFileType ,)*] no On which kinds of editors belonging to certain file types this menu item will be shown. Defaults to empty. If empty, it will not be hidden based on editor file types. n/a required-editor-selection-types = [($EditorSelectionType ,)*] no On which kinds of editor selection types this menu item will be shown. Defaults to empty. If empty, it will not be hidden based on editor selections. n/a display-name = $Expression no The display name of the command action. Defaults to the display name of the command String description = $Expression no The description of he command action. Defaults to the description of the command String The following ResourceType s are supported: Directory : the menu item will only be shown when a directory is selected. File : the menu item will only be shown when a file is selected. The following EnclosingResourceType s are supported: Project : the menu item will only be shown when the selected resource has an enclosing project. Directory: : the menu item will only be shown when the selected resource has an enclosing directory. The following EditorFileType s are supported: HierarchicalResource : the menu item will only be shown when the editor belongs to a hierarchical resource. That is, a resource that belongs to a tree, such as a file or directory on the local filesystem. ReadableResource : the menu item will only be shown when the editor belongs to a readable resource. The following EditorSelectionType s are supported: Region : the menu item will only be shown when a region with size >0 in the source file is selected. Offset : the menu item will only be shown in the context of an editor with a cursor. Menus \u00b6 Menu items are assigned to 3 particular menus: editor-context-menu [ $MenuItem* ] : the context menu that gets shown in editors of the language, for example when right-clicking in an editor of the language in an IDE. Spoofax automatically creates a top-level submenu with the name of the language to host the editor context menu items. The required-editor-file-types and required-editor-selection-types options are used to filter menu items. resource-context-menu [ $MenuItem* ] : the context menu that gets shown in resource explorers, for example when right-clicking in the file browser in an IDE. Spoofax automatically creates a top-level submenu with the name of the language to host the editor context menu items. The required-resource-types and required-enclosing-resource-types options are used to filter menu items. main-menu [ $MenuIitem* ] : the main menu of the language, which is shown on the menu bar in IDEs. When no main-menu section is given, it defaults to the same menu as editor-context-menu . For example, we can assign the command defined earlier to several menus: editor-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] } ] ] Language feature sections \u00b6 Parser \u00b6 The parser { $ParserOption* } section enables generation of a parser, and groups options. The sdf3 section must be enabled when the parser section is enabled. The following ParserOption s are supported: Syntax Required? Description Type default-start-symbol = $Expression yes The start symbol to use when no specific one is provided. SDF3 sort identifier variant = $ParserVariant no The parser variant to use. Defaults to jsglr1 . n/a The following ParserVariant s are supported: jsglr1 : uses the JSGLR1 parser. jsglr2 { $Jsglr2Option* } : uses the JSGLR2 parser. The following Jsglr2Option s are supported: preset = $Jsglr2Preset : sets the JSGLR2 preset to use. The following Jsglr2Preset s are supported: Standard Elkhound Recovery RecoveryElkhound DataDependent LayoutSensitive Composite Incremental IncrementalRecovery Styler \u00b6 The styler { $StylerOption* } section enables generation of a styler, and groups options. The esv section must be enabled when the styler section is enabled. Currently, no StylerOption s are supported. Constraint analyzer \u00b6 The constraint-analyzer { $ConstraintAnalyzerOption* } section enables generation of a constraint analyzer, and groups options. The statix section must be enabled when the constraint-analyzer section is enabled. The following ConstraintAnalyzerOption s are supported: Syntax Required? Description Type multi-file = $Expression no Whether multi-file analysis is enabled. Defaults to false . Boolean stratego-strategy = Expression no The stratego strategy entry-point that handles communication with the constraint-solver. Defaults to editor-analyze . Stratego strategy identifier Multi-language analyzer \u00b6 The multilang-analyzer { $MultilangAnalyzerOption* } section enables generation of a multi-language analyzer, and groups options. The constraint-analyzer and statix sections must be enabled when the multilang-analyzer section is enabled. Currently, no MultilangAnalyzerOption s are supported. Stratego runtime \u00b6 The stratego-runtime { $StrategoRuntimeOption* } section enables generation of a stratego runtime, and groups options. The stratego section must be enabled when the stratego-runtime section is enabled. Currently, no StrategoRuntimeOption s are supported. Completer \u00b6 The completer { $CompleterOption* } section enables generation of a code completer, and groups options. The constraint-analyzer and statix sections must be enabled when the completer section is enabled. Currently, no CompleterOption s are supported. Editor services \u00b6 The editor-services { $EditorServiceSubsection* } groups editor service sub-sections. The following EditorServiceSubsection s are supported. Reference resolution \u00b6 The reference resolution editor service is enabled with reference-resolution = $ReferenceResolutionVariant . The following ReferenceResolutionVariant s are supported: Stratego-based: stratego { strategy = strategy $Strategy } where Strategy is a Stratego strategy, typically editor-resolve . Hover tooltips \u00b6 The hover tooltip editor service is enabled with hover = $HoverVariant . The following $HoverVariant s are supported: Stratego-based: stratego { strategy = strategy $Strategy } where Strategy is a Stratego strategy, typically editor-hover . Meta-language sections \u00b6 SDF3 \u00b6 The sdf3 { $Sdf3Option* } section enables syntax definition with SDF3 . The parser section must be enabled when the sdf3 section is enabled. The following Sdf3Option s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main SDF3 file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main SDF3 file relative to the main-source-directory . Defaults to ./start.sdf3 . Path parse-table-generator { $ParseTableGeneratorOption* } no Parse table generator options. n/a The following ParseTableGeneratorOption s are supported: Syntax Required? Description Type dynamic = $Expression no Whether the generated parse table is dynamic. Defaults to false . Boolean data-dependent = $Expression no Whether the generated parse table is data-dependent. Defaults to false . Boolean layout-sensitive = $Expression no Whether the generated parse table is layout-sensitive. Defaults to false . Boolean solve-deep-conflicts = $Expression no Whether the parse table generator solves deep priority conflicts. Defaults to true . Boolean check-overlap = $Expression no Whether the parse table generator checks for overlap. Defaults to false . Boolean check-priorities = $Expression no Whether the parse table generator checks priorities. Defaults to false . Boolean ESV \u00b6 The esv { $EsvOption* } section enables syntax-based styling definition with ESV . The styler section must be enabled when the esv section is enabled. The following EsvOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main ESV file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main ESV file relative to the main-source-directory . Defaults to ./main.esv . Path include-directory = $Expression no Adds an include directory from which to resolve ESV imports. May be given multiple times. Path Statix \u00b6 The statix { $StatixOption* } section enables static semantics definition with Statix . The constraint-anaylzer section must be enabled when the statix section is enabled. The following StatixOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main Statix file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main Statix file relative to the main-source-directory . Defaults to ./main.stx . Path sdf3-statix-signature-generation = $Expression no Whether SDF3 to Statix signature generation is enabled. When enabled, stratego { sdf3-statix-explication-generation = true } must also be enabled. Defaults to false . Boolean Stratego \u00b6 The stratego { $StrategoOption* } section enables definition of transformations with Stratego . The stratego-runtime section must be enabled when the stratego section is enabled. The following StrategoOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main Stratego file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main Stratego file relative to the main-source-directory . Defaults to ./main.stx . Path language-strategy-affix = $Expression no The affix that is used to make certain generated strategies unique to the language. This is used both as a prefix and suffix. Defaults to name of the language transformed to a Stratego strategy identifier. Stratego strategy identifier sdf3-statix-explication-generation = $Expression no Whether SDF3 to Statix injection explication/implication generation is enabled. When enabled, statix { sdf3-statix-signature-generation = true } must also be enabled. Defaults to false . Boolean spoofaxc.lock \u00b6 The spoofaxc.lock file, which resides next to the spoofaxc.cfg file, contains values for several options that have defaults derived from other options, in order to keep these derived values stable even when the options they are derived from are changed. For example, when no java-class-id-prefix option is set in spoofaxc.cfg , it will be derived from the name option with some changes to make it compatible as a Java identifier, and is stored under shared.defaultClassPrefix in the spoofaxc.lock file. When you change the name of your language, the stored value will be used, keeping the class prefix the same, making it possible to rename the language without having to rename all class files. Therefore, the spoofaxc.lock file should be checked in to source control, in order to have reproducible builds. If you do want to re-derive a default from other options, remove the option from the spoofaxc.lock file and rebuild the language. The value will be re-derived and stored in spoofaxc.lock , after which you need to check it into source control again.","title":"Configuration"},{"location":"reference/configuration/#configuration","text":"The main entry point of a language definition is the spoofaxc.cfg (Spoofax compiler configuration) file, written in the CFG language. The goal of this config file is to configure basic options, enable/disable features, point to main source files of meta-languages, to add/override behaviour, and to serve as an anchor on the filesystem. The directory that the spoofaxc.cfg file is in is called the \"root directory\" of the language definition, and any relative paths are resolved relative to that directory. The CFG language has domain-specific syntax for configuring language definitions. However, the syntax follows these conventions: Options are assigned a value with $Option = $Expression . Unless specified otherwise, options may only be given once. Sections $Section { ... } may enable features and group options. Lists $List [ ..., ... ] indicate an option/section may be given 0-many times. Let bindings let $Name = $Expression can be used to give values a name that can be (re-)used in the rest of the configuration file. If something in the documentation is unclear, the CFG language definition can be found here . In its most basic form, the spoofaxc.cfg file for a language named Calc looks as follows: name = \"Calc\" which assigns the string \"Calc\" to the name option. A more interesting example configures more options and enables syntax definition: name = \"Calc\" java-class-id-prefix = java Calc file-extension = \"calc\" sdf3 {} parser { default-start-symbol = sort Program } Here, java Calc is assigned to the java-class-id-prefix option. The sdf3 {} section from the example is empty, but is used to enable the SDF3 meta-language. The parser section enables generation of a parser, and also sets the default start symbol to use to sort Program .","title":"Configuration"},{"location":"reference/configuration/#literals","text":"Literals are expressions that are usually directly assigned to options, or bound to a name with let bindings. CFG has the following literals: Syntax Example(s) Type (true|false) true false Boolean \"(~[\\\"\\$\\n\\r\\\\] | \\\\~[\\n\\r])*\" \"foo\" \"bar\" String (./|/)~[\\n\\r\\,\\;\\]\\)\\}\\ ]* ./relative/file /absolute/file Filesystem path $JavaIdChars Java foo Java identifier $JavaQIdLit Java foo.bar.Baz Qualified Java identifier task-def $JavaQIdLit task-def foo.bar.Baz Qualified Java identifier that represents a task definition sort [a-zA-Z0-9\\-\\_\\$]+ sort Start SDF3 sort identifier strategy [a-zA-Z0-9\\-\\_\\$]+ strategy Start Stratego strategy identifier With the following syntax non-terminals: Name Syntax JavaIdChars [a-zA-Z\\_\\$][a-zA-Z0-9\\_\\$]* JavaQIdLit $JavaIdChars(\\.$JavaIdChars)* For Java, SDF3 sort, and Stratego strategy identifiers, the corresponding keywords of those languages are rejected as identifiers.","title":"Literals"},{"location":"reference/configuration/#let-bindings","text":"Let bindings of the form let $Name = $Expression bind a name to an expression, for example: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst let showParsedAstCommand = command-def { task-def = showParsedAst ... } editor-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand ... } ] ] creates a binding from name showParsedAst to task-def mb.helloworld.task.HelloWorldShowParsedAst , which we then pass to the task-def option in command-def . The command in turn is bound to showParsedAstCommand , assigned to the command-def option in a command-action section.","title":"Let bindings"},{"location":"reference/configuration/#top-level-options","text":"The following top-level options exist: Syntax Required? Description Type group = $Expression no Group identifier of the language, used as the group / groupId in the Java ecosystem. Defaults to org.metaborg . String id = $Expression no Artifact identifier of the language, used as the name / artifactId in the Java ecosystem. Defaults to the name of the language uncapitalized. String name = $Expression yes Name of the language. String version = $Expression no Version of the language, used as the version in the Java ecosystem. Defaults to 0.1.0 . String file-extension = $Expression no File extension of the language. May be given multiple times. Defaults to the name of the language transformed to fit in 3 characters. String java-package-id-prefix = $Expression no The prefix to add before all package identifiers in Java source files. Defaults to mb.$Name where $Name is transformed to be a valid package identifier. Qualified Java identifier java-class-id-prefix = $Expression no The prefix to add before all Java classes. Defaults to the name of the language transformed to be a valid class identifier. Java identifier source-directory = $Expression no Path relative to the root directory that has the sources of the language definition. Defaults to src . Path build-directory = $Expression no Path relative to the root directory that has the generated sources and build outputs when building the language definition. Defaults to build . Path","title":"Top-level options"},{"location":"reference/configuration/#commands","text":"Commands are sections that are also expressions, typically assigned to a name with a let binding, with the following form: let $Name = command-def { $CommandOption* } The following options are available in a command: Syntax Required? Description Type task-def = $Expression yes The task definition that the command will execute. Qualified Java identifier that represents a task definition, or qualified Java identifier type = $Expression no The fully qualified Java type we want this command to be generated as. Can be omitted to generate a type based on the name of the task definition. Qualified Java identifier display-name = $Expression yes The display name of the command. String description = $Expression no The optional description of the command. String supported-execution-types = [($ExecutionType ,)*] no The optional supported execution types of the command. Defaults to [Once, Continuous] . n/a args-type = $Expression no The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. Qualified Java identifier parameters = [ $Parameter* ] yes The description of the parameters of the command n/a The following ExecutionType s are supported: Once indicates a that this command supports being executed as a one-shot command. Continuous indicates that this command supports being executed every time the source file changes. A $Parameter has the form $Identifier = parameter { $ParameterOptions } with the following options: Syntax Required? Description Type type = $Expression yes The fully qualified Java of the type of the parameter. This must match the type of the parameter inside the args-type of the command. Qualified Java identifier required = $Expression no Whether the parameter is required. Defaults to true . Boolean converter-type = $Expression no The argument converter for this parameter, which can convert a String value to the type of this parameter. Must implement the ArgConverter interface. Qualified Java identifier argument-providers = [($ArgumentProvider ,)*] no Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. If no arguments can be provided, and the argument is required, then the argument must be provided by the user that executes the command, or executing the command will fail. n/a The following ArgumentProvider s are supported: Value($Expression) provides a default value given by the expression. The expression must match the type of the parameter, even though this is not currently checked. Context($CommandContext) attempts to infer the argument by context. The following CommandContext s are supported: Directory : attempt to infer a ResourcePath to an existing directory. For example, when right-clicking a directory in an IDE to execute a command on that directory. File : attempt to infer a ResourcePath to an existing file. For example, when right-clicking a file in an IDE to execute a command on that directory, or when executing a command in an editor for a file. HierarchicalResource : attempt to infer a ResourcePath to a hierarchical resource. A hierarchical resource is a resource that belongs to a (tree) hierarchy, such as a file or directory on the local filesystem. Use this when the command relies on the resource being in a filesystem, but does not care whether it is a directory or a file. ReadableResource : attempt to infer a ResourceKey to a readable resource. This is more general than File , as we only ask for a resource that can be read, not one that belongs to a (local) filesystem. Use this when the command does not rely on the resource being in a filesystem. Region : attempt to infer a Region in a source file. Inference succeeds when the context has a selection of size 1 or larger. For example, when executing a command in an editor that has a selection, the region will be that selection. Offset : attempt to infer an int representing an offset in a source file. Inference succeeds when the context has a cursor offset (i.e., a selection of size 0 or larger). For example, when executing a command in an editor, the offset will be the offset to the cursor in the editor. EnclosingContext($EnclosingCommandContext) attempts to infer the argument by the enclosing context. The following EnclosingCommandContext s are supported: Project : attempt to infer a ResourcePath to the enclosing project. For example, when executing a command in an IDE on a file, directory, or editor for a file, that belongs to a project. Or when executing a command in a CLI, the directory will be the current working directory. Directory : attempt to infer a ResourcePath to the enclosing directory. For example, when executing a command in the context of a file, directory, or editor for a file, the directory will be the parent of that file/directory. Here is an example of a command that shows the parsed AST by taking one file argument that is inferred from context: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand task-def = showParsedAst args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args display-name = \"Show parsed AST\" description = \"Shows the parsed AST\" supported-execution-types = [Once, Continuous] parameters = [ file = parameter { type = java mb.resource.ResourceKey required = true argument-providers = [Context(ResourceKey)] } ] }","title":"Commands"},{"location":"reference/configuration/#menu-items","text":"Menu items take the form of: a separator representing a horizontal line in a menu used to separate groups of menu items. a menu $Expression [ $MenuItem* ] representing a (nested) menu with a display name defined by the expression which must be a string, and a list of nested menu items. a command-action { $CommandActionOption* } representing an action that executes a command when a user clicks on it. A command action has the following options: Syntax Required? Description Type command-def = $Expression yes The command to execute. Command or qualified Java identifier execution-type = $ExecutionType yes How the command should be executed. n/a required-resource-types = [($ResourceType ,)*] no On which kinds of resources this menu item will be shown on resource context menus. Defaults to empty. If empty, it will not be hidden based on resources. n/a required-enclosing-resource-types = [($EnclosingResourceType ,)*] no On which kinds of enclosing resources this menu item will be shown on resource context menus. Defaults to empty. If empty, it will not be hidden based on enclosing resource. n/a required-editor-file-types = [($EditorFileType ,)*] no On which kinds of editors belonging to certain file types this menu item will be shown. Defaults to empty. If empty, it will not be hidden based on editor file types. n/a required-editor-selection-types = [($EditorSelectionType ,)*] no On which kinds of editor selection types this menu item will be shown. Defaults to empty. If empty, it will not be hidden based on editor selections. n/a display-name = $Expression no The display name of the command action. Defaults to the display name of the command String description = $Expression no The description of he command action. Defaults to the description of the command String The following ResourceType s are supported: Directory : the menu item will only be shown when a directory is selected. File : the menu item will only be shown when a file is selected. The following EnclosingResourceType s are supported: Project : the menu item will only be shown when the selected resource has an enclosing project. Directory: : the menu item will only be shown when the selected resource has an enclosing directory. The following EditorFileType s are supported: HierarchicalResource : the menu item will only be shown when the editor belongs to a hierarchical resource. That is, a resource that belongs to a tree, such as a file or directory on the local filesystem. ReadableResource : the menu item will only be shown when the editor belongs to a readable resource. The following EditorSelectionType s are supported: Region : the menu item will only be shown when a region with size >0 in the source file is selected. Offset : the menu item will only be shown in the context of an editor with a cursor.","title":"Menu items"},{"location":"reference/configuration/#menus","text":"Menu items are assigned to 3 particular menus: editor-context-menu [ $MenuItem* ] : the context menu that gets shown in editors of the language, for example when right-clicking in an editor of the language in an IDE. Spoofax automatically creates a top-level submenu with the name of the language to host the editor context menu items. The required-editor-file-types and required-editor-selection-types options are used to filter menu items. resource-context-menu [ $MenuItem* ] : the context menu that gets shown in resource explorers, for example when right-clicking in the file browser in an IDE. Spoofax automatically creates a top-level submenu with the name of the language to host the editor context menu items. The required-resource-types and required-enclosing-resource-types options are used to filter menu items. main-menu [ $MenuIitem* ] : the main menu of the language, which is shown on the menu bar in IDEs. When no main-menu section is given, it defaults to the same menu as editor-context-menu . For example, we can assign the command defined earlier to several menus: editor-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] } ] ]","title":"Menus"},{"location":"reference/configuration/#language-feature-sections","text":"","title":"Language feature sections"},{"location":"reference/configuration/#parser","text":"The parser { $ParserOption* } section enables generation of a parser, and groups options. The sdf3 section must be enabled when the parser section is enabled. The following ParserOption s are supported: Syntax Required? Description Type default-start-symbol = $Expression yes The start symbol to use when no specific one is provided. SDF3 sort identifier variant = $ParserVariant no The parser variant to use. Defaults to jsglr1 . n/a The following ParserVariant s are supported: jsglr1 : uses the JSGLR1 parser. jsglr2 { $Jsglr2Option* } : uses the JSGLR2 parser. The following Jsglr2Option s are supported: preset = $Jsglr2Preset : sets the JSGLR2 preset to use. The following Jsglr2Preset s are supported: Standard Elkhound Recovery RecoveryElkhound DataDependent LayoutSensitive Composite Incremental IncrementalRecovery","title":"Parser"},{"location":"reference/configuration/#styler","text":"The styler { $StylerOption* } section enables generation of a styler, and groups options. The esv section must be enabled when the styler section is enabled. Currently, no StylerOption s are supported.","title":"Styler"},{"location":"reference/configuration/#constraint-analyzer","text":"The constraint-analyzer { $ConstraintAnalyzerOption* } section enables generation of a constraint analyzer, and groups options. The statix section must be enabled when the constraint-analyzer section is enabled. The following ConstraintAnalyzerOption s are supported: Syntax Required? Description Type multi-file = $Expression no Whether multi-file analysis is enabled. Defaults to false . Boolean stratego-strategy = Expression no The stratego strategy entry-point that handles communication with the constraint-solver. Defaults to editor-analyze . Stratego strategy identifier","title":"Constraint analyzer"},{"location":"reference/configuration/#multi-language-analyzer","text":"The multilang-analyzer { $MultilangAnalyzerOption* } section enables generation of a multi-language analyzer, and groups options. The constraint-analyzer and statix sections must be enabled when the multilang-analyzer section is enabled. Currently, no MultilangAnalyzerOption s are supported.","title":"Multi-language analyzer"},{"location":"reference/configuration/#stratego-runtime","text":"The stratego-runtime { $StrategoRuntimeOption* } section enables generation of a stratego runtime, and groups options. The stratego section must be enabled when the stratego-runtime section is enabled. Currently, no StrategoRuntimeOption s are supported.","title":"Stratego runtime"},{"location":"reference/configuration/#completer","text":"The completer { $CompleterOption* } section enables generation of a code completer, and groups options. The constraint-analyzer and statix sections must be enabled when the completer section is enabled. Currently, no CompleterOption s are supported.","title":"Completer"},{"location":"reference/configuration/#editor-services","text":"The editor-services { $EditorServiceSubsection* } groups editor service sub-sections. The following EditorServiceSubsection s are supported.","title":"Editor services"},{"location":"reference/configuration/#reference-resolution","text":"The reference resolution editor service is enabled with reference-resolution = $ReferenceResolutionVariant . The following ReferenceResolutionVariant s are supported: Stratego-based: stratego { strategy = strategy $Strategy } where Strategy is a Stratego strategy, typically editor-resolve .","title":"Reference resolution"},{"location":"reference/configuration/#hover-tooltips","text":"The hover tooltip editor service is enabled with hover = $HoverVariant . The following $HoverVariant s are supported: Stratego-based: stratego { strategy = strategy $Strategy } where Strategy is a Stratego strategy, typically editor-hover .","title":"Hover tooltips"},{"location":"reference/configuration/#meta-language-sections","text":"","title":"Meta-language sections"},{"location":"reference/configuration/#sdf3","text":"The sdf3 { $Sdf3Option* } section enables syntax definition with SDF3 . The parser section must be enabled when the sdf3 section is enabled. The following Sdf3Option s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main SDF3 file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main SDF3 file relative to the main-source-directory . Defaults to ./start.sdf3 . Path parse-table-generator { $ParseTableGeneratorOption* } no Parse table generator options. n/a The following ParseTableGeneratorOption s are supported: Syntax Required? Description Type dynamic = $Expression no Whether the generated parse table is dynamic. Defaults to false . Boolean data-dependent = $Expression no Whether the generated parse table is data-dependent. Defaults to false . Boolean layout-sensitive = $Expression no Whether the generated parse table is layout-sensitive. Defaults to false . Boolean solve-deep-conflicts = $Expression no Whether the parse table generator solves deep priority conflicts. Defaults to true . Boolean check-overlap = $Expression no Whether the parse table generator checks for overlap. Defaults to false . Boolean check-priorities = $Expression no Whether the parse table generator checks priorities. Defaults to false . Boolean","title":"SDF3"},{"location":"reference/configuration/#esv","text":"The esv { $EsvOption* } section enables syntax-based styling definition with ESV . The styler section must be enabled when the esv section is enabled. The following EsvOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main ESV file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main ESV file relative to the main-source-directory . Defaults to ./main.esv . Path include-directory = $Expression no Adds an include directory from which to resolve ESV imports. May be given multiple times. Path","title":"ESV"},{"location":"reference/configuration/#statix","text":"The statix { $StatixOption* } section enables static semantics definition with Statix . The constraint-anaylzer section must be enabled when the statix section is enabled. The following StatixOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main Statix file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main Statix file relative to the main-source-directory . Defaults to ./main.stx . Path sdf3-statix-signature-generation = $Expression no Whether SDF3 to Statix signature generation is enabled. When enabled, stratego { sdf3-statix-explication-generation = true } must also be enabled. Defaults to false . Boolean","title":"Statix"},{"location":"reference/configuration/#stratego","text":"The stratego { $StrategoOption* } section enables definition of transformations with Stratego . The stratego-runtime section must be enabled when the stratego section is enabled. The following StrategoOption s are supported: Syntax Required? Description Type main-source-directory = $Expression no The directory relative to the root directory that contains the main Stratego file. Defaults to the value of the top-level source-directory option. Path main-file = $Expression no The main Stratego file relative to the main-source-directory . Defaults to ./main.stx . Path language-strategy-affix = $Expression no The affix that is used to make certain generated strategies unique to the language. This is used both as a prefix and suffix. Defaults to name of the language transformed to a Stratego strategy identifier. Stratego strategy identifier sdf3-statix-explication-generation = $Expression no Whether SDF3 to Statix injection explication/implication generation is enabled. When enabled, statix { sdf3-statix-signature-generation = true } must also be enabled. Defaults to false . Boolean","title":"Stratego"},{"location":"reference/configuration/#spoofaxclock","text":"The spoofaxc.lock file, which resides next to the spoofaxc.cfg file, contains values for several options that have defaults derived from other options, in order to keep these derived values stable even when the options they are derived from are changed. For example, when no java-class-id-prefix option is set in spoofaxc.cfg , it will be derived from the name option with some changes to make it compatible as a Java identifier, and is stored under shared.defaultClassPrefix in the spoofaxc.lock file. When you change the name of your language, the stored value will be used, keeping the class prefix the same, making it possible to rename the language without having to rename all class files. Therefore, the spoofaxc.lock file should be checked in to source control, in order to have reproducible builds. If you do want to re-derive a default from other options, remove the option from the spoofaxc.lock file and rebuild the language. The value will be re-derived and stored in spoofaxc.lock , after which you need to check it into source control again.","title":"spoofaxc.lock"},{"location":"reference/language_definition/","text":"Language definition \u00b6 In essence, a language definition in Spoofax 3 consists of several source files along with configuration that specify and implement the various aspects of a language, such as its tokenizer, parser, styler, completer, checker, compiler, commands, and so forth. The source files of a language definition are mostly written in high-level domain-specific meta-languages, with some parts being written in Java. The Spoofax 3 compiler compiles language definitions into language implementations which are essentially standard Java libraries (e.g., JAR files) consisting of Java classes and bundled resources. These classes implement the various aspects of a language, and may use bundled resources such as a parse table which is loaded and interpreted at runtime. In this reference manual we explain the basic anatomy of a language definition, its configuration and file structure, Java classes and how they are instantiated, as well as how a language definition is compiled into a language implementation. Anatomy \u00b6 configuration in CFG syntax in SDF3 styling in ESV static semantics in Statix transformations in Stratego tasks in java (future: PIE DSL) commands, specified in configuration, generated for you menu bindings CLI bindings File structure \u00b6 Java classes \u00b6 description of the Java classes, their instances, and how they are instantiated basic classes: ClassLoaderResources ParseTable/ParserFactory/Parser StylingRules/StylerFactory/Styler StrategoRuntimeBuilderFactory ConstraintAnalyzerFactory/ConstraintAnalyzer components: ResourcesComponent/ResourcesModule Component/Module Scope/Qualifier how they are instantiated by Dagger LanguageInstance: tasks command defs auto command request CLI commands menu items task definitions: Tokenize Style Completion Check/CheckMulti/CheckAggregator/CheckDeaggregator Parse Analyze/AnalyzeMulti GetStrategoRuntimeProvider commands: Instantiation \u00b6 dependency injection Compilation \u00b6 description of how a language definition is compiled into a language implementation, and what the compiled form looks like. generate Java sources into: build/generated/sources/language build/generated/sources/adapter generate Stratego sources into: build/generated/sources/languageSpecification/stratego","title":"Language definition"},{"location":"reference/language_definition/#language-definition","text":"In essence, a language definition in Spoofax 3 consists of several source files along with configuration that specify and implement the various aspects of a language, such as its tokenizer, parser, styler, completer, checker, compiler, commands, and so forth. The source files of a language definition are mostly written in high-level domain-specific meta-languages, with some parts being written in Java. The Spoofax 3 compiler compiles language definitions into language implementations which are essentially standard Java libraries (e.g., JAR files) consisting of Java classes and bundled resources. These classes implement the various aspects of a language, and may use bundled resources such as a parse table which is loaded and interpreted at runtime. In this reference manual we explain the basic anatomy of a language definition, its configuration and file structure, Java classes and how they are instantiated, as well as how a language definition is compiled into a language implementation.","title":"Language definition"},{"location":"reference/language_definition/#anatomy","text":"configuration in CFG syntax in SDF3 styling in ESV static semantics in Statix transformations in Stratego tasks in java (future: PIE DSL) commands, specified in configuration, generated for you menu bindings CLI bindings","title":"Anatomy"},{"location":"reference/language_definition/#file-structure","text":"","title":"File structure"},{"location":"reference/language_definition/#java-classes","text":"description of the Java classes, their instances, and how they are instantiated basic classes: ClassLoaderResources ParseTable/ParserFactory/Parser StylingRules/StylerFactory/Styler StrategoRuntimeBuilderFactory ConstraintAnalyzerFactory/ConstraintAnalyzer components: ResourcesComponent/ResourcesModule Component/Module Scope/Qualifier how they are instantiated by Dagger LanguageInstance: tasks command defs auto command request CLI commands menu items task definitions: Tokenize Style Completion Check/CheckMulti/CheckAggregator/CheckDeaggregator Parse Analyze/AnalyzeMulti GetStrategoRuntimeProvider commands:","title":"Java classes"},{"location":"reference/language_definition/#instantiation","text":"dependency injection","title":"Instantiation"},{"location":"reference/language_definition/#compilation","text":"description of how a language definition is compiled into a language implementation, and what the compiled form looks like. generate Java sources into: build/generated/sources/language build/generated/sources/adapter generate Stratego sources into: build/generated/sources/languageSpecification/stratego","title":"Compilation"},{"location":"release/download/","text":"Downloads \u00b6 This page contains download links to the latest release and development version of Spoofax 3. Latest release \u00b6 The latest release of Spoofax is 0.8.0, released on 28-05-2021. We recommend the use of releases because we make sure to make them available indefinitely. Follow the Installation tutorial for instructions on how to install and run Spoofax. Eclipse Language Workbench Environment \u00b6 With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit Repository for installing into an existing Eclipse installation: https://artifacts.metaborg.org/content/unzip/releases-unzipped/org/metaborg/spoofax.lwb.eclipse.repository/0.8.0/spoofax.lwb.eclipse.repository-0.8.0.zip-unzip/ Development version \u00b6 The development version of Spoofax is always develop-SNAPSHOT . Development versions of Spoofax use snapshot versioning, meaning that they always point to the latest build that is made whenever a change is pushed to Spoofax\u2019s repositories. Therefore, older builds are not available since they are continuously replaced by newer builds. We do not recommend usage of the development version unless you absolutely need its features, want to help us test, or if you know what you are doing. Eclipse Language Workbench Environment \u00b6 With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Downloads"},{"location":"release/download/#downloads","text":"This page contains download links to the latest release and development version of Spoofax 3.","title":"Downloads"},{"location":"release/download/#latest-release","text":"The latest release of Spoofax is 0.8.0, released on 28-05-2021. We recommend the use of releases because we make sure to make them available indefinitely. Follow the Installation tutorial for instructions on how to install and run Spoofax.","title":"Latest release"},{"location":"release/download/#eclipse-language-workbench-environment","text":"With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit Repository for installing into an existing Eclipse installation: https://artifacts.metaborg.org/content/unzip/releases-unzipped/org/metaborg/spoofax.lwb.eclipse.repository/0.8.0/spoofax.lwb.eclipse.repository-0.8.0.zip-unzip/","title":"Eclipse Language Workbench Environment"},{"location":"release/download/#development-version","text":"The development version of Spoofax is always develop-SNAPSHOT . Development versions of Spoofax use snapshot versioning, meaning that they always point to the latest build that is made whenever a change is pushed to Spoofax\u2019s repositories. Therefore, older builds are not available since they are continuously replaced by newer builds. We do not recommend usage of the development version unless you absolutely need its features, want to help us test, or if you know what you are doing.","title":"Development version"},{"location":"release/download/#eclipse-language-workbench-environment_1","text":"With embedded JVM: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM Without embedded JVM: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Eclipse Language Workbench Environment"},{"location":"tutorial/create_language_project/","text":"Creating a language project \u00b6 This tutorial gets you started with language development by creating a language project and changing various aspects of the language. First follow the installation tutorial if you haven't done so yet. Creating a new project \u00b6 In Eclipse, open the new project dialog by choosing File \u2023 New \u2023 Project from the main menu. In the new project dialog, select Spoofax LWB \u2023 Spoofax language project and press Next . In this wizard, you can customize the various names your language will use. However, for the purpose of this tutorial, fill in HelloWorld as the name of the project, which will automatically fill in the other elements with defaults. Then press Finish to create the project. There should now be a project named helloworld in the Package Explorer . Adding syntax \u00b6 First we will add some syntax to the language. Open the main SDF3 file helloworld/src/start.sdf3 file by expanding the folders and double-clicking the file. SDF3 is a meta-language (i.e., a language to describe languages) for describing the syntax of a language, from which Spoofax will derive the parser of your language. Under the context-free syntax section, replace the Start . Empty = <> line with Start . Program = <<{ Part \" \" } * >> , indicating that the language accepts programs which consists of zero or more parts. Part is a sort and must be defined by adding its name to the context-free sorts section on a new line. Now we will add syntax productions to Part to the context-free syntax section. Add Part . Hello = < hello > on a new line, indicating that one sort of Part is the word hello. Then add Part . World = < world > on a new line, indicating that one sort of Part is the word world . src/start.sdf3 full contents module start context-free start-symbols Start context-free sorts Start Part context-free syntax Start . Program = <<{ Part \" \" } * >> Part . Hello = < hello > Part . World = < world > lexical syntax LAYOUT = [ \\ \\ n \\ v \\ f \\ r ] context-free restrictions LAYOUT ? - / - [ \\ \\ n \\ v \\ f \\ r ] To test our change, build the project by clicking on the project in the Package Explorer and choosing Project \u2023 Build Project from the main menu, or by pressing Cmd + B on macOS or Ctrl + B on others. To see when the build is done, open the progress window by choosing Window \u2023 Show View \u2023 Progress . If the progress view is empty, the build is done. The initial build can be a bit slow because there is a lot of code to compile in the background. Subsequent builds will be faster due to incrementalization. Create a test file for your language by right-clicking the project and choosing New \u2023 File , filling in test.hel as file name, and pressing Finish . Type a valid sentence such as hello world hello hello world in this file, and it will highlight purple indicating that hello and world are keywords. Changing syntax highlighting \u00b6 Now we will change the syntax highlighter of the language. Open the main ESV file helloworld/src/main.esv . ESV is a meta-language for describing the syntax highlighter. Change the keyword : 127 0 85 bold line to keyword : 0 0 150 bold and build the project. Then check your test.hel example file, it should now be highlighted blue. To make iteration easier, you can drag the test.hel tab to the side of the screen to open the language definition and example file side-by-side. You can play around with the coloring a bit and choose a style to your liking. Remember to rebuild the project after making a change to the language definition. Adding a debugging command \u00b6 It can be quite handy to look at the AST of a program that the parser of the language produces as a debugging tool. To do that, we will write a task definition that produces the AST of a program by parsing it, we will add a command definition for that task, and finally we will bind the command to a menu item so that we can execute the command. Creating the task definition \u00b6 A task definition is a piece of code that take some input, may read from or write to files, run and get the result of other tasks, and produce some output. Task definitions come from PIE , a framework for developing composable, incremental, correct, and expressive pipelines and build scripts. All user interaction, pipelines, and builds in Spoofax 3 are composed of task definitions. So whenever you want to perform a command, present feedback to the user, or compile your language, you will need to write a task definition for it. For brevity, we usually just refer to a \"task definition\" by \"task\". For PIE to be able to incrementally execute your task, you must make your dependencies explicit. That is, dependencies to files and other tasks must be made explicit. However, because PIE supports dynamic dependencies , those dependencies are made while the build script is executing . A full tutorial on PIE is outside the scope of this tutorial, but we will implement several tasks in this tutorial, explain the PIE concepts, and how Spoofax 3 uses these concepts. A task definition is written as a class in Java, and needs to adhere to a certain interface. Let's start by creating the class for this task. First, right-click the helloworld/src/main/java directory and choose New \u2023 Package , replace the name with mb.helloworld.task , and press Finish . Then, right-click the mb.helloworld.task package we just created and choose New \u2023 Class and fill in HelloWorldShowParsedAst as name, then press Finish . Replace the entire Java file with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import org.spoofax.interpreter.terms.IStrategoTerm ; import mb.common.result.Result ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.jsglr.common.JsglrParseException ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.aterm.common.TermToString ; @HelloWorldScope // (10) public class HelloWorldShowParsedAst implements TaskDef < HelloWorldShowParsedAst . Args , CommandFeedback > { // (1) public static class Args implements Serializable { // (2) private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { // (3) context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); // (4) final ResourceKey file = args . file ; final Result < IStrategoTerm , JsglrParseException > astResult = context . require ( parse . inputBuilder (). withFile ( file ). buildAstSupplier ()); // (5) return astResult . mapOrElse ( // (6) ast -> CommandFeedback . of ( ShowFeedback . showText ( TermToString . toString ( ast ), \"Parsed AST for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { // (7) return getClass (). getName (); } // (8) private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; @Inject // (9) public HelloWorldShowParsedAst ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse ) { this . classloaderResources = classloaderResources ; this . parse = parse ; } } We explain this class with numbered annotations in the above Java source file: This class implements TaskDef , which is an interface from PIE which a class must implement to be a task definition. Task definitions have an input and output type defined by the first and second generic argument. To execute this task, an object of the input type is required, and once it is done executing, it must return an object of the output type. In this concrete case, the input type is HelloWorldShowParsedAst . Args which is a nested data class defined at (2). The output is CommandFeedback which is a type defined by Spoofax for providing feedback back to the user when executing a command. All tasks that are executed through commands must return a CommandFeedback object. A nested data class encapsulating the input to this task. In this case, we want this task to take the file we are going to show the AST of as input. Even though we only take one argument as input, we must encapsulate it in a class due to the way commands in Spoofax work. This data class must implement Serializable because it is used as an input to a task. In order for PIE to incrementalize tasks across JVM restarts, it must be able to serialize the input (and output) objects to disk. Furthermore, this class must be immutable, because PIE caches input (and output) objects, and this caching would be inconsistent if the class is mutable. This class is immutable by storing the file in a final field which is set in the constructor (and the ResourceKey class is immutable as well). Spoofax and PIE abstract over files with resources . A resource is some externally managed mutable state, with a (immutable and serializable) key which can be used to identify, read, and write to that resource. Such a key is represented by a ResourceKey . Finally, this data class must implement equals and hashCode according to the data in the class because PIE uses these methods to identify tasks according to their input, which in turn is used for caching. A toString implementation is also recommended for debugging. The exec method which is called when the task is executed. It takes an ExecContext as input, which is used to tell PIE about dependencies to files, and can be used to execute and get the result of another task (implicitly creating a dependency to that task). It also takes the input type Args as input, and must return a CommandFeedback . For sound incrementality, we want to re-execute this task when we make changes to this class. Therefore, we want to make a self-dependency . That is, we want to make a file dependency to the Java class file that is compiled from this Java source file. The classloaderResources object (defined below at (8)) is used to get the class or JAR file of the current class. This resource is passed to context . require to tell PIE that this task depends on that file. We pass in ResourceStampers . hashFile () as the second argument, which indicates that we want to use the hash of the class file to detect changes, instead of the last modified date which is used by default. It is recommended to use hashes for dependencies to generated/compiled files, as compiled files are sometimes recompiled without changes, which changes the modified date but not the hash, leading to better incrementality. To show the AST we must parse the input file, and in order to do that we must call a task which performs the parsing. Whereas (4) uses context . require to create a dependency to a file , we use context . require here to create a dependency to the task that does the parsing, and get the output of that task. As input to context . require we pass parse . inputBuilder (). withFile ( file ). buildAstSupplier () , which uses the builder pattern to create an input for the parse task and then extracts the AST from the output. Internally, the parse task creates a dependency to the file we pass into it. We depend on the parse task. Therefore, when the file changes, PIE re-executes the parse task, and then re-executes this task if the output of the parse task is different. Thereby, PIE incrementally executes your task without having to incrementalize it yourself. The output of the parse task is Result < IStrategoTerm , JSGLR1ParseException > which is a result type which is either a IStrategoTerm representing the AST of the file if parsing succeeds, or a JSGLR1ParseException when parsing fails. Instead of throwing exceptions, we use result types (akin to Either in Haskell or Result in Rust) to model the possibility of failure with values. We do this to make it possible to work with failures in PIE tasks. In PIE, throwing an exception signifies an unrecoverable error and cancels the entire pipeline. However, using failures as values works normally. Now that we have the result of parsing, we can turn it into a CommandFeedback object. We use mapOrElse of Result to map the result to a CommandFeedback differently depending on whether parsing succeeded or failed. If parsing succeeded, we show the AST as text to the user with CommandFeedback . of ( ShowFeedback . showText (...)) with the first argument providing the text, and the second argument providing the title. The IDE then shows this as a textual editor. If parsing failed, we present the parse error messages as feedback to the user with CommandFeedback . ofTryExtractMessagesFrom . Finally, PIE needs to be able to identify this task definition. That is done by this getId method that returns a unique identifier. This can almost always be implemented using getClass (). getName () which returns the fully qualified name of this class. Spoofax uses dependency injection to inject required services, tasks, and other objects into the objects of your classes. The classloaderResources object used in (4) is of type HelloWorldClassLoaderResources which is class that Spoofax generates for your language. Similarly, the parse object used in (5) is of type HelloWorldParse which is a task definition that Spoofax generates for you. We store these as fields of this class. Note that dependency injection, and file/task dependencies in PIE, are two completely separate things. These fields are set using constructor injection in the single constructor of this class marked with @Inject . The dependency injection framework that Spoofax uses (the Dagger framework) will then instantiate your class with instances of the dependencies. Finally, we must tell the dependency injection framework to which scope instances of this class belongs. We annotate the class with @HelloWorldScope which is a scope annotation that Spoofax generates for you. This is mainly used to differentiate between different languages when multiple languages are composed, which we do not do in this tutorial, but is required nonetheless. Registering the task definition \u00b6 We must register this task in order for Spoofax to know about it. Open the CFG helloworld/spoofax.cfg file. The CFG meta-language is a configuration language where we configure and glue together the various aspects of your language. Add the following configuration to the end of the file: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst This registers the task definition class that we just created, and makes it available under the showParsedAst name in the configuration. Warning Spoofax assumes that this class implements TaskDef . This is not checked as part of this configuration. Faults will lead to Java compile errors. Creating the command \u00b6 To create the command, add the following configuration to the end of the spoofax.cfg file: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand // (1) task-def = showParsedAst // (2) args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args // (3) display-name = \"Show parsed AST\" // (4) description = \"Shows the parsed AST\" // (5) supported-execution-types = [Once, Continuous] // (6) parameters = [ // (7) file = parameter { // (7a) type = java mb.resource.ResourceKey // (7b) required = true // (7c) argument-providers = [Context(ReadableResource)] // (7d) } ] } Spoofax generates a Java class implementing the command boilerplate for you. This is the fully qualified Java type we want this command to have. Can be omitted to generate a type based on the name of the task definition. The task definition that the command will execute, which is the showParsedAst we defined earlier. The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. The display name of the command. The optional description of the command. The optional supported execution types of the command. Once indicates a one-shot command, while Continuous indicates a command that is executed every time the source file changes. Defaults to [Once, Continuous] . The description of the parameters of the command: The name of the parameter. The fully qualified Java of the type of the parameter. This must match the type we used in the HelloWorldShowParsedAst . Args class before. Whether the parameter is required. Defaults to true . Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. Because this argument is a ResourceKey that should point to a readable resource, we want to try to infer the file from context, so we use Context(ReadableResource) . When we execute this command on a \"Hello world\" file in the IDE, Spoofax will automatically infer that file as the argument for the parameter, because the file is a readable resource. Currently, Spoofax does not support running commands in the IDE without an argument provider, so a working argument provider is currently required. Warning Spoofax assumes that: a) the task definition's input type is the one defined at (3), b) the output type is CommandFeedback , and c) that the argument type has a constructor covering exactly the parameters from (7). This is not checked as part of this configuration. Faults will lead to Java compile errors. Some properties set above are set to their conventional (default) value, or are optional, so we can leave them out. Replace the command definition with the following code: let showParsedAstCommand = command-def { task-def = showParsedAst display-name = \"Show parsed AST\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(ReadableResource)] } ] } Adding the menu item \u00b6 To add the menu item, add the following configuration to the end of the spoofax.cfg file: editor-context-menu [ // (1) menu \"Debug\" [ // (2) command-action { // (3) command-def = showParsedAstCommand // (3a) execution-type = Once // (3b) } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ // (4) menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] // (5) } ] ] An editor-context-menu section adds menu items to the editor context menu. That is, the menu that pops up when you right-click inside an editor for your language. There is also a main-menu section for adding menu items to the main menu when an editor for your language has focus. If no main-menu section is defined, the main menu will take all menu items from editor-context-menu . A nested menu with name \"Debug\" . An action menu item that executes a command. The command to execute. How the command should be executed. Once to execute it once, Continuous to continuously execute the command when the source file changes. A resource-context-menu section adds menu items to the context menu of the resource browser. That is, the menu that pops up when you right-click a file of your language. For menu items inside a resource-context-menu to show up, they must specify on what kind of resource types they are shown. In this case, we want the command to show up when files of our language are selected in when the resource context menu pops up, so we choose [File] . Build the project so that we can test our changes. Open the test.hel file and right-click inside the editor area to open the context menu. From the editor context menu, select HelloWorld \u2023 Debug \u2023 Show parsed AST . A new editor will pop up with the result of the command, showing the AST of your example file. Close the result and now run HelloWorld \u2023 Debug \u2023 Show parsed AST (continuous) . Drag the resulting editor to the side and edit the example project, the resulting editor will update whenever the example file changes. We can also run the command by activating the test.hel editor by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the main menu. Finally, we can run the command by right-clicking the test.hel file in the Package Explorer by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the context menu. Changing the static semantics \u00b6 Now we will change the static semantics of the language. Open the main Statix file helloworld/src/main.stx Statix is a meta-language for defining the static semantics of your language, which includes type checking. First we will update the Statix specification to handle the new language constructs. Replace the programOk ( _ ). line with programOk(Program(parts)) :- partsOk(parts). , meaning that we accept programs consisting of parts, as long as their parts are ok. As a silly rule, we will add a warning to all instances of world in the program. Add the following code to the end of the Statix definition: partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) This adds a partOk rule that lets all Hello () parts pass, but will add a warning to all World () parts. partsOk goes over a list of parts and applies partOk . src/main.stx full contents module main imports signatures / start-sig rules programOk : Start programOk ( Program ( parts )) : - partsOk ( parts ). partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) Build the project, and a warning marker should appear under all instances of world in the example program. Adding a transformation \u00b6 Finally, we will define a transformation for our language and add a task, command-tasks, command, and menu item for it. Open the main Stratego file helloworld/src/main.str . Stratego is a meta-language for defining term ( AST ) transformations through rewrite rules. We will add a silly transformation that replaces all instances of World () with Hello () . Add the following code to the end of the Stratego file: rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) The replace-world rule passes Hello () terms but rewrites World () terms to Hello () . The replace-worlds strategy tries to apply replace-world in a top-down manner over the entire AST . src/main.str full contents module main imports statixruntime statix / api injections / - signatures / - rules // Analysis pre-analyze = explicate-injections-helloworld-Start post-analyze = implicate-injections-helloworld-Start editor-analyze = stx-editor-analyze ( pre-analyze , post-analyze | \"main\" , \"programOk\" ) rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) Now we add a task and command-task for this transformation. We define two separate tasks to keep separate the act of transforming the program, and feeding back the result of that transformation to the user that executes a command. This practice later allows us to reuse the first task in a different task if we need to. Right-click the mb.helloworld.task package and create the HelloWorldReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package mb.helloworld.task ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.stratego.pie.AstStrategoTransformTaskDef ; import javax.inject.Inject ; import java.io.IOException ; @HelloWorldScope public class HelloWorldReplaceWorlds extends AstStrategoTransformTaskDef { private final HelloWorldClassLoaderResources classloaderResources ; @Inject public HelloWorldReplaceWorlds ( // 1 HelloWorldClassLoaderResources classloaderResources , HelloWorldGetStrategoRuntimeProvider getStrategoRuntimeProvider ) { super ( getStrategoRuntimeProvider , \"replace-worlds\" ); // 2 this . classloaderResources = classloaderResources ; } @Override public String getId () { // 3 return getClass (). getName (); } @Override protected void createDependencies ( ExecContext context ) throws IOException { // 4 context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); } } This task extends AstStrategoTransformTaskDef which is a convenient abstract class for creating tasks that run Stratego transformations by implementing a constructor and a couple of methods: The constructor should inject HelloWorldClassLoaderResources which we again will use to create a self-dependency, and HelloWorldGetStrategoRuntimeProvider which is a task that Spoofax generates for your language, which provides a Stratego runtime to execute strategies with. The HelloWorldGetStrategoRuntimeProvider instance is provided to the superclass constructor, along with the strategy that we want this task to execute, which is \"replace-worlds\" . We override getId of TaskDef again to give this task a unique identifier. We override createDependencies of AstStrategoTransformTaskDef to create a self-dependency. Then create the HelloWorldShowReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.aterm.common.TermToString ; @HelloWorldScope public class HelloWorldShowReplaceWorlds implements TaskDef < HelloWorldShowReplaceWorlds . Args , CommandFeedback > { public static class Args implements Serializable { private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; private final HelloWorldReplaceWorlds replaceWorlds ; @Inject public HelloWorldShowReplaceWorlds ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse , HelloWorldReplaceWorlds replaceWorlds ) { this . classloaderResources = classloaderResources ; this . parse = parse ; this . replaceWorlds = replaceWorlds ; } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); final ResourceKey file = args . file ; return context . require ( replaceWorlds , parse . inputBuilder (). withFile ( file ). buildAstSupplier ()). mapOrElse ( ast -> CommandFeedback . of ( ShowFeedback . showText ( TermToString . toString ( ast ), \"Replaced World()s with Hello()s for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { return getClass (). getName (); } } This class very similar to HelloWorldShowParsedAst , but runs the HelloWorldReplaceWorlds task on the parsed AST , transforming the AST . Now open helloworld/spoofax.cfg again and register the tasks by adding: task-def mb.helloworld.task.HelloWorldReplaceWorlds let showReplaceWorlds = task-def mb.helloworld.task.HelloWorldShowReplaceWorlds Then add a command for it by adding: let showReplaceWorldsCommand = command-def { task-def = showReplaceWorlds display-name = \"Replace world with hello\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(ReadableResource)] } ] } Finally, add menu items for the command by adding: editor-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once } command-action { command-def = showReplaceWorldsCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once required-resource-types = [File] } ] ] Build the project so that we can test our changes. Test the command similarly to testing the \"Show parsed AST \" command.","title":"Creating a language project"},{"location":"tutorial/create_language_project/#creating-a-language-project","text":"This tutorial gets you started with language development by creating a language project and changing various aspects of the language. First follow the installation tutorial if you haven't done so yet.","title":"Creating a language project"},{"location":"tutorial/create_language_project/#creating-a-new-project","text":"In Eclipse, open the new project dialog by choosing File \u2023 New \u2023 Project from the main menu. In the new project dialog, select Spoofax LWB \u2023 Spoofax language project and press Next . In this wizard, you can customize the various names your language will use. However, for the purpose of this tutorial, fill in HelloWorld as the name of the project, which will automatically fill in the other elements with defaults. Then press Finish to create the project. There should now be a project named helloworld in the Package Explorer .","title":"Creating a new project"},{"location":"tutorial/create_language_project/#adding-syntax","text":"First we will add some syntax to the language. Open the main SDF3 file helloworld/src/start.sdf3 file by expanding the folders and double-clicking the file. SDF3 is a meta-language (i.e., a language to describe languages) for describing the syntax of a language, from which Spoofax will derive the parser of your language. Under the context-free syntax section, replace the Start . Empty = <> line with Start . Program = <<{ Part \" \" } * >> , indicating that the language accepts programs which consists of zero or more parts. Part is a sort and must be defined by adding its name to the context-free sorts section on a new line. Now we will add syntax productions to Part to the context-free syntax section. Add Part . Hello = < hello > on a new line, indicating that one sort of Part is the word hello. Then add Part . World = < world > on a new line, indicating that one sort of Part is the word world . src/start.sdf3 full contents module start context-free start-symbols Start context-free sorts Start Part context-free syntax Start . Program = <<{ Part \" \" } * >> Part . Hello = < hello > Part . World = < world > lexical syntax LAYOUT = [ \\ \\ n \\ v \\ f \\ r ] context-free restrictions LAYOUT ? - / - [ \\ \\ n \\ v \\ f \\ r ] To test our change, build the project by clicking on the project in the Package Explorer and choosing Project \u2023 Build Project from the main menu, or by pressing Cmd + B on macOS or Ctrl + B on others. To see when the build is done, open the progress window by choosing Window \u2023 Show View \u2023 Progress . If the progress view is empty, the build is done. The initial build can be a bit slow because there is a lot of code to compile in the background. Subsequent builds will be faster due to incrementalization. Create a test file for your language by right-clicking the project and choosing New \u2023 File , filling in test.hel as file name, and pressing Finish . Type a valid sentence such as hello world hello hello world in this file, and it will highlight purple indicating that hello and world are keywords.","title":"Adding syntax"},{"location":"tutorial/create_language_project/#changing-syntax-highlighting","text":"Now we will change the syntax highlighter of the language. Open the main ESV file helloworld/src/main.esv . ESV is a meta-language for describing the syntax highlighter. Change the keyword : 127 0 85 bold line to keyword : 0 0 150 bold and build the project. Then check your test.hel example file, it should now be highlighted blue. To make iteration easier, you can drag the test.hel tab to the side of the screen to open the language definition and example file side-by-side. You can play around with the coloring a bit and choose a style to your liking. Remember to rebuild the project after making a change to the language definition.","title":"Changing syntax highlighting"},{"location":"tutorial/create_language_project/#adding-a-debugging-command","text":"It can be quite handy to look at the AST of a program that the parser of the language produces as a debugging tool. To do that, we will write a task definition that produces the AST of a program by parsing it, we will add a command definition for that task, and finally we will bind the command to a menu item so that we can execute the command.","title":"Adding a debugging command"},{"location":"tutorial/create_language_project/#creating-the-task-definition","text":"A task definition is a piece of code that take some input, may read from or write to files, run and get the result of other tasks, and produce some output. Task definitions come from PIE , a framework for developing composable, incremental, correct, and expressive pipelines and build scripts. All user interaction, pipelines, and builds in Spoofax 3 are composed of task definitions. So whenever you want to perform a command, present feedback to the user, or compile your language, you will need to write a task definition for it. For brevity, we usually just refer to a \"task definition\" by \"task\". For PIE to be able to incrementally execute your task, you must make your dependencies explicit. That is, dependencies to files and other tasks must be made explicit. However, because PIE supports dynamic dependencies , those dependencies are made while the build script is executing . A full tutorial on PIE is outside the scope of this tutorial, but we will implement several tasks in this tutorial, explain the PIE concepts, and how Spoofax 3 uses these concepts. A task definition is written as a class in Java, and needs to adhere to a certain interface. Let's start by creating the class for this task. First, right-click the helloworld/src/main/java directory and choose New \u2023 Package , replace the name with mb.helloworld.task , and press Finish . Then, right-click the mb.helloworld.task package we just created and choose New \u2023 Class and fill in HelloWorldShowParsedAst as name, then press Finish . Replace the entire Java file with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import org.spoofax.interpreter.terms.IStrategoTerm ; import mb.common.result.Result ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.jsglr.common.JsglrParseException ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.aterm.common.TermToString ; @HelloWorldScope // (10) public class HelloWorldShowParsedAst implements TaskDef < HelloWorldShowParsedAst . Args , CommandFeedback > { // (1) public static class Args implements Serializable { // (2) private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { // (3) context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); // (4) final ResourceKey file = args . file ; final Result < IStrategoTerm , JsglrParseException > astResult = context . require ( parse . inputBuilder (). withFile ( file ). buildAstSupplier ()); // (5) return astResult . mapOrElse ( // (6) ast -> CommandFeedback . of ( ShowFeedback . showText ( TermToString . toString ( ast ), \"Parsed AST for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { // (7) return getClass (). getName (); } // (8) private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; @Inject // (9) public HelloWorldShowParsedAst ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse ) { this . classloaderResources = classloaderResources ; this . parse = parse ; } } We explain this class with numbered annotations in the above Java source file: This class implements TaskDef , which is an interface from PIE which a class must implement to be a task definition. Task definitions have an input and output type defined by the first and second generic argument. To execute this task, an object of the input type is required, and once it is done executing, it must return an object of the output type. In this concrete case, the input type is HelloWorldShowParsedAst . Args which is a nested data class defined at (2). The output is CommandFeedback which is a type defined by Spoofax for providing feedback back to the user when executing a command. All tasks that are executed through commands must return a CommandFeedback object. A nested data class encapsulating the input to this task. In this case, we want this task to take the file we are going to show the AST of as input. Even though we only take one argument as input, we must encapsulate it in a class due to the way commands in Spoofax work. This data class must implement Serializable because it is used as an input to a task. In order for PIE to incrementalize tasks across JVM restarts, it must be able to serialize the input (and output) objects to disk. Furthermore, this class must be immutable, because PIE caches input (and output) objects, and this caching would be inconsistent if the class is mutable. This class is immutable by storing the file in a final field which is set in the constructor (and the ResourceKey class is immutable as well). Spoofax and PIE abstract over files with resources . A resource is some externally managed mutable state, with a (immutable and serializable) key which can be used to identify, read, and write to that resource. Such a key is represented by a ResourceKey . Finally, this data class must implement equals and hashCode according to the data in the class because PIE uses these methods to identify tasks according to their input, which in turn is used for caching. A toString implementation is also recommended for debugging. The exec method which is called when the task is executed. It takes an ExecContext as input, which is used to tell PIE about dependencies to files, and can be used to execute and get the result of another task (implicitly creating a dependency to that task). It also takes the input type Args as input, and must return a CommandFeedback . For sound incrementality, we want to re-execute this task when we make changes to this class. Therefore, we want to make a self-dependency . That is, we want to make a file dependency to the Java class file that is compiled from this Java source file. The classloaderResources object (defined below at (8)) is used to get the class or JAR file of the current class. This resource is passed to context . require to tell PIE that this task depends on that file. We pass in ResourceStampers . hashFile () as the second argument, which indicates that we want to use the hash of the class file to detect changes, instead of the last modified date which is used by default. It is recommended to use hashes for dependencies to generated/compiled files, as compiled files are sometimes recompiled without changes, which changes the modified date but not the hash, leading to better incrementality. To show the AST we must parse the input file, and in order to do that we must call a task which performs the parsing. Whereas (4) uses context . require to create a dependency to a file , we use context . require here to create a dependency to the task that does the parsing, and get the output of that task. As input to context . require we pass parse . inputBuilder (). withFile ( file ). buildAstSupplier () , which uses the builder pattern to create an input for the parse task and then extracts the AST from the output. Internally, the parse task creates a dependency to the file we pass into it. We depend on the parse task. Therefore, when the file changes, PIE re-executes the parse task, and then re-executes this task if the output of the parse task is different. Thereby, PIE incrementally executes your task without having to incrementalize it yourself. The output of the parse task is Result < IStrategoTerm , JSGLR1ParseException > which is a result type which is either a IStrategoTerm representing the AST of the file if parsing succeeds, or a JSGLR1ParseException when parsing fails. Instead of throwing exceptions, we use result types (akin to Either in Haskell or Result in Rust) to model the possibility of failure with values. We do this to make it possible to work with failures in PIE tasks. In PIE, throwing an exception signifies an unrecoverable error and cancels the entire pipeline. However, using failures as values works normally. Now that we have the result of parsing, we can turn it into a CommandFeedback object. We use mapOrElse of Result to map the result to a CommandFeedback differently depending on whether parsing succeeded or failed. If parsing succeeded, we show the AST as text to the user with CommandFeedback . of ( ShowFeedback . showText (...)) with the first argument providing the text, and the second argument providing the title. The IDE then shows this as a textual editor. If parsing failed, we present the parse error messages as feedback to the user with CommandFeedback . ofTryExtractMessagesFrom . Finally, PIE needs to be able to identify this task definition. That is done by this getId method that returns a unique identifier. This can almost always be implemented using getClass (). getName () which returns the fully qualified name of this class. Spoofax uses dependency injection to inject required services, tasks, and other objects into the objects of your classes. The classloaderResources object used in (4) is of type HelloWorldClassLoaderResources which is class that Spoofax generates for your language. Similarly, the parse object used in (5) is of type HelloWorldParse which is a task definition that Spoofax generates for you. We store these as fields of this class. Note that dependency injection, and file/task dependencies in PIE, are two completely separate things. These fields are set using constructor injection in the single constructor of this class marked with @Inject . The dependency injection framework that Spoofax uses (the Dagger framework) will then instantiate your class with instances of the dependencies. Finally, we must tell the dependency injection framework to which scope instances of this class belongs. We annotate the class with @HelloWorldScope which is a scope annotation that Spoofax generates for you. This is mainly used to differentiate between different languages when multiple languages are composed, which we do not do in this tutorial, but is required nonetheless.","title":"Creating the task definition"},{"location":"tutorial/create_language_project/#registering-the-task-definition","text":"We must register this task in order for Spoofax to know about it. Open the CFG helloworld/spoofax.cfg file. The CFG meta-language is a configuration language where we configure and glue together the various aspects of your language. Add the following configuration to the end of the file: let showParsedAst = task-def mb.helloworld.task.HelloWorldShowParsedAst This registers the task definition class that we just created, and makes it available under the showParsedAst name in the configuration. Warning Spoofax assumes that this class implements TaskDef . This is not checked as part of this configuration. Faults will lead to Java compile errors.","title":"Registering the task definition"},{"location":"tutorial/create_language_project/#creating-the-command","text":"To create the command, add the following configuration to the end of the spoofax.cfg file: let showParsedAstCommand = command-def { type = java mb.helloworld.command.HelloWorldShowParsedAstCommand // (1) task-def = showParsedAst // (2) args-type = java mb.helloworld.task.HelloWorldShowParsedAst.Args // (3) display-name = \"Show parsed AST\" // (4) description = \"Shows the parsed AST\" // (5) supported-execution-types = [Once, Continuous] // (6) parameters = [ // (7) file = parameter { // (7a) type = java mb.resource.ResourceKey // (7b) required = true // (7c) argument-providers = [Context(ReadableResource)] // (7d) } ] } Spoofax generates a Java class implementing the command boilerplate for you. This is the fully qualified Java type we want this command to have. Can be omitted to generate a type based on the name of the task definition. The task definition that the command will execute, which is the showParsedAst we defined earlier. The fully qualified Java type of the argument class. Can be omitted if the argument class is a nested class named Args of the task definition. The display name of the command. The optional description of the command. The optional supported execution types of the command. Once indicates a one-shot command, while Continuous indicates a command that is executed every time the source file changes. Defaults to [Once, Continuous] . The description of the parameters of the command: The name of the parameter. The fully qualified Java of the type of the parameter. This must match the type we used in the HelloWorldShowParsedAst . Args class before. Whether the parameter is required. Defaults to true . Argument providers for this parameter that attempt to automatically provide a fitting argument. When providing an argument fails, the next argument provider in the list will be attempted. Because this argument is a ResourceKey that should point to a readable resource, we want to try to infer the file from context, so we use Context(ReadableResource) . When we execute this command on a \"Hello world\" file in the IDE, Spoofax will automatically infer that file as the argument for the parameter, because the file is a readable resource. Currently, Spoofax does not support running commands in the IDE without an argument provider, so a working argument provider is currently required. Warning Spoofax assumes that: a) the task definition's input type is the one defined at (3), b) the output type is CommandFeedback , and c) that the argument type has a constructor covering exactly the parameters from (7). This is not checked as part of this configuration. Faults will lead to Java compile errors. Some properties set above are set to their conventional (default) value, or are optional, so we can leave them out. Replace the command definition with the following code: let showParsedAstCommand = command-def { task-def = showParsedAst display-name = \"Show parsed AST\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(ReadableResource)] } ] }","title":"Creating the command"},{"location":"tutorial/create_language_project/#adding-the-menu-item","text":"To add the menu item, add the following configuration to the end of the spoofax.cfg file: editor-context-menu [ // (1) menu \"Debug\" [ // (2) command-action { // (3) command-def = showParsedAstCommand // (3a) execution-type = Once // (3b) } command-action { command-def = showParsedAstCommand execution-type = Continuous } ] ] resource-context-menu [ // (4) menu \"Debug\" [ command-action { command-def = showParsedAstCommand execution-type = Once required-resource-types = [File] // (5) } ] ] An editor-context-menu section adds menu items to the editor context menu. That is, the menu that pops up when you right-click inside an editor for your language. There is also a main-menu section for adding menu items to the main menu when an editor for your language has focus. If no main-menu section is defined, the main menu will take all menu items from editor-context-menu . A nested menu with name \"Debug\" . An action menu item that executes a command. The command to execute. How the command should be executed. Once to execute it once, Continuous to continuously execute the command when the source file changes. A resource-context-menu section adds menu items to the context menu of the resource browser. That is, the menu that pops up when you right-click a file of your language. For menu items inside a resource-context-menu to show up, they must specify on what kind of resource types they are shown. In this case, we want the command to show up when files of our language are selected in when the resource context menu pops up, so we choose [File] . Build the project so that we can test our changes. Open the test.hel file and right-click inside the editor area to open the context menu. From the editor context menu, select HelloWorld \u2023 Debug \u2023 Show parsed AST . A new editor will pop up with the result of the command, showing the AST of your example file. Close the result and now run HelloWorld \u2023 Debug \u2023 Show parsed AST (continuous) . Drag the resulting editor to the side and edit the example project, the resulting editor will update whenever the example file changes. We can also run the command by activating the test.hel editor by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the main menu. Finally, we can run the command by right-clicking the test.hel file in the Package Explorer by choosing Spoofax \u2023 Debug \u2023 Show parsed AST from the context menu.","title":"Adding the menu item"},{"location":"tutorial/create_language_project/#changing-the-static-semantics","text":"Now we will change the static semantics of the language. Open the main Statix file helloworld/src/main.stx Statix is a meta-language for defining the static semantics of your language, which includes type checking. First we will update the Statix specification to handle the new language constructs. Replace the programOk ( _ ). line with programOk(Program(parts)) :- partsOk(parts). , meaning that we accept programs consisting of parts, as long as their parts are ok. As a silly rule, we will add a warning to all instances of world in the program. Add the following code to the end of the Statix definition: partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) This adds a partOk rule that lets all Hello () parts pass, but will add a warning to all World () parts. partsOk goes over a list of parts and applies partOk . src/main.stx full contents module main imports signatures / start-sig rules programOk : Start programOk ( Program ( parts )) : - partsOk ( parts ). partOk : Part partOk ( Hello ()). partOk ( World ()) : - try { false } | warning $[ World !] . partsOk maps partOk ( list ( * )) Build the project, and a warning marker should appear under all instances of world in the example program.","title":"Changing the static semantics"},{"location":"tutorial/create_language_project/#adding-a-transformation","text":"Finally, we will define a transformation for our language and add a task, command-tasks, command, and menu item for it. Open the main Stratego file helloworld/src/main.str . Stratego is a meta-language for defining term ( AST ) transformations through rewrite rules. We will add a silly transformation that replaces all instances of World () with Hello () . Add the following code to the end of the Stratego file: rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) The replace-world rule passes Hello () terms but rewrites World () terms to Hello () . The replace-worlds strategy tries to apply replace-world in a top-down manner over the entire AST . src/main.str full contents module main imports statixruntime statix / api injections / - signatures / - rules // Analysis pre-analyze = explicate-injections-helloworld-Start post-analyze = implicate-injections-helloworld-Start editor-analyze = stx-editor-analyze ( pre-analyze , post-analyze | \"main\" , \"programOk\" ) rules replace-world : Hello () - > Hello () replace-world : World () - > Hello () replace-worlds = topdown ( try ( replace-world )) Now we add a task and command-task for this transformation. We define two separate tasks to keep separate the act of transforming the program, and feeding back the result of that transformation to the user that executes a command. This practice later allows us to reuse the first task in a different task if we need to. Right-click the mb.helloworld.task package and create the HelloWorldReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package mb.helloworld.task ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.stratego.pie.AstStrategoTransformTaskDef ; import javax.inject.Inject ; import java.io.IOException ; @HelloWorldScope public class HelloWorldReplaceWorlds extends AstStrategoTransformTaskDef { private final HelloWorldClassLoaderResources classloaderResources ; @Inject public HelloWorldReplaceWorlds ( // 1 HelloWorldClassLoaderResources classloaderResources , HelloWorldGetStrategoRuntimeProvider getStrategoRuntimeProvider ) { super ( getStrategoRuntimeProvider , \"replace-worlds\" ); // 2 this . classloaderResources = classloaderResources ; } @Override public String getId () { // 3 return getClass (). getName (); } @Override protected void createDependencies ( ExecContext context ) throws IOException { // 4 context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); } } This task extends AstStrategoTransformTaskDef which is a convenient abstract class for creating tasks that run Stratego transformations by implementing a constructor and a couple of methods: The constructor should inject HelloWorldClassLoaderResources which we again will use to create a self-dependency, and HelloWorldGetStrategoRuntimeProvider which is a task that Spoofax generates for your language, which provides a Stratego runtime to execute strategies with. The HelloWorldGetStrategoRuntimeProvider instance is provided to the superclass constructor, along with the strategy that we want this task to execute, which is \"replace-worlds\" . We override getId of TaskDef again to give this task a unique identifier. We override createDependencies of AstStrategoTransformTaskDef to create a self-dependency. Then create the HelloWorldShowReplaceWorlds class and replace the entire Java file with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package mb.helloworld.task ; import java.io.Serializable ; import java.util.Objects ; import javax.inject.Inject ; import org.checkerframework.checker.nullness.qual.Nullable ; import mb.helloworld.HelloWorldClassLoaderResources ; import mb.helloworld.HelloWorldScope ; import mb.pie.api.ExecContext ; import mb.pie.api.TaskDef ; import mb.pie.api.stamp.resource.ResourceStampers ; import mb.resource.ResourceKey ; import mb.spoofax.core.language.command.CommandFeedback ; import mb.spoofax.core.language.command.ShowFeedback ; import mb.aterm.common.TermToString ; @HelloWorldScope public class HelloWorldShowReplaceWorlds implements TaskDef < HelloWorldShowReplaceWorlds . Args , CommandFeedback > { public static class Args implements Serializable { private static final long serialVersionUID = 1L ; public final ResourceKey file ; public Args ( ResourceKey file ) { this . file = file ; } @Override public boolean equals ( @Nullable Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; final Args args = ( Args ) o ; return file . equals ( args . file ); } @Override public int hashCode () { return Objects . hash ( file ); } @Override public String toString () { return \"Args{\" + \"file=\" + file + '}' ; } } private final HelloWorldClassLoaderResources classloaderResources ; private final HelloWorldParse parse ; private final HelloWorldReplaceWorlds replaceWorlds ; @Inject public HelloWorldShowReplaceWorlds ( HelloWorldClassLoaderResources classloaderResources , HelloWorldParse parse , HelloWorldReplaceWorlds replaceWorlds ) { this . classloaderResources = classloaderResources ; this . parse = parse ; this . replaceWorlds = replaceWorlds ; } @Override public CommandFeedback exec ( ExecContext context , Args args ) throws Exception { context . require ( classloaderResources . tryGetAsLocalResource ( getClass ()), ResourceStampers . hashFile ()); final ResourceKey file = args . file ; return context . require ( replaceWorlds , parse . inputBuilder (). withFile ( file ). buildAstSupplier ()). mapOrElse ( ast -> CommandFeedback . of ( ShowFeedback . showText ( TermToString . toString ( ast ), \"Replaced World()s with Hello()s for '\" + file + \"'\" )), e -> CommandFeedback . ofTryExtractMessagesFrom ( e , file ) ); } @Override public String getId () { return getClass (). getName (); } } This class very similar to HelloWorldShowParsedAst , but runs the HelloWorldReplaceWorlds task on the parsed AST , transforming the AST . Now open helloworld/spoofax.cfg again and register the tasks by adding: task-def mb.helloworld.task.HelloWorldReplaceWorlds let showReplaceWorlds = task-def mb.helloworld.task.HelloWorldShowReplaceWorlds Then add a command for it by adding: let showReplaceWorldsCommand = command-def { task-def = showReplaceWorlds display-name = \"Replace world with hello\" parameters = [ file = parameter { type = java mb.resource.ResourceKey argument-providers = [Context(ReadableResource)] } ] } Finally, add menu items for the command by adding: editor-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once } command-action { command-def = showReplaceWorldsCommand execution-type = Continuous } ] ] resource-context-menu [ menu \"Transform\" [ command-action { command-def = showReplaceWorldsCommand execution-type = Once required-resource-types = [File] } ] ] Build the project so that we can test our changes. Test the command similarly to testing the \"Show parsed AST \" command.","title":"Adding a transformation"},{"location":"tutorial/install/","text":"Installing the Spoofax 3 language workbench \u00b6 This tutorial gets you set up for language development in Spoofax 3 by installing the Spoofax 3 Eclipse LWB environment. Requirements \u00b6 Spoofax 3 runs on the major operating systems: Windows (64 bits) macOS (64 bits) Linux (64 bits) Other than that, nothing is required as everything is contained in the archive we are going to download. Download \u00b6 To get started, we will download a premade Eclipse installation that comes bundled with the Spoofax 3 LWB plugin. We will download version 0.8.0 released on 28-05-2021. Download the latest version for your platform: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM These are bundled with an embedded JVM so that you do not need to have a JVM installed. If your system has a JVM of version 11 or higher installed, and would rather use that, use the following download links instead: Windows 64-bit macOS 64-bit Linux 64-bit Unpack \u00b6 Unpack the downloaded archive to a directory with write access. Write access is required because Eclipse needs to write to several configuration files inside its installation. Warning The unpacked directory or application may be renamed, but do not include spaces or other characters that would not be allowed in a URI (i.e., : ? # [ ] @ ). The same is true for the directory the archive is extracted to. Failing to do so breaks a built-in classpath detection mechanism which will cause Java compilation errors. Warning On Windows do not unpack the Eclipse installation into Program Files , because no write access is granted there, breaking both Eclipse and Spoofax. Running Eclipse \u00b6 Start up Eclipse, depending on your operating system: Windows: run Spoofax3/eclipse.exe macOS run Spoofax3.app Linux run Spoofax3/eclipse Warning macOS Sierra (10.12) and above will mark the unpacked Spoofax3.app as \"damaged\" due to a modified signed/notarized application, because we have modified the eclipse.ini file inside it. To fix this, open the Terminal, navigate to the directory where the Spoofax3.app file is located, and execute: xattr -rc Spoofax3.app After starting up, choose where your workspace will be stored. The Eclipse workspace will contain all of your settings, and is the default location for new projects. Configuring Eclipse's preferences \u00b6 Some Eclipse preferences unfortunately have sub-optimal defaults. After you have chosen a workspace and Eclipse has completely started up (and you have closed the Welcome page), go to the Eclipse preferences by pressing Cmd + , on macOS and ??? on others, and set these options: General \u2023 Startup and Shutdown Enable: Refresh workspace on startup General \u2023 Workspace Enable: Refresh using native hooks or polling General \u2023 Workspace \u2023 Build Enable: Save automatically before manual build Finally, we need to make sure that Eclipse has detected an installed JRE . Open the Eclipse preferences and go to the Java \u2023 Installed JREs page: If there are no installed JREs, and you've downloaded an Eclipse installation with an embedded JVM , press Search... and navigate to the location where you unpacked the Eclipse installation, and choose the jvm directory in it. Then press the checkmark of the JRE to activate it. If there are no installed JREs, and you've downloaded an Eclipse installation without an embedded JVM , press Search... and navigate to the location where your JVM installed, and choose it. Then press the checkmark of the JRE to activate it. If there are one or more installed JVMs, but none are selected, select an appropriate one by pressing the checkmark. If there are one or more installed JVMs, and one is selected, you are good to go. Tip These preferences are stored per workspace. If you create a fresh workspace, you have to re-do these settings. You can create a new workspace with copied preferences by selecting File \u2023 Switch workspace \u2023 Other... , and then checking Preferences under Copy settings . Now that Eclipse is set up, continue with creating a language project","title":"Installing the Spoofax 3 language workbench"},{"location":"tutorial/install/#installing-the-spoofax-3-language-workbench","text":"This tutorial gets you set up for language development in Spoofax 3 by installing the Spoofax 3 Eclipse LWB environment.","title":"Installing the Spoofax 3 language workbench"},{"location":"tutorial/install/#requirements","text":"Spoofax 3 runs on the major operating systems: Windows (64 bits) macOS (64 bits) Linux (64 bits) Other than that, nothing is required as everything is contained in the archive we are going to download.","title":"Requirements"},{"location":"tutorial/install/#download","text":"To get started, we will download a premade Eclipse installation that comes bundled with the Spoofax 3 LWB plugin. We will download version 0.8.0 released on 28-05-2021. Download the latest version for your platform: Windows 64-bit with embedded JVM macOS 64-bit with embedded JVM Linux 64-bit with embedded JVM These are bundled with an embedded JVM so that you do not need to have a JVM installed. If your system has a JVM of version 11 or higher installed, and would rather use that, use the following download links instead: Windows 64-bit macOS 64-bit Linux 64-bit","title":"Download"},{"location":"tutorial/install/#unpack","text":"Unpack the downloaded archive to a directory with write access. Write access is required because Eclipse needs to write to several configuration files inside its installation. Warning The unpacked directory or application may be renamed, but do not include spaces or other characters that would not be allowed in a URI (i.e., : ? # [ ] @ ). The same is true for the directory the archive is extracted to. Failing to do so breaks a built-in classpath detection mechanism which will cause Java compilation errors. Warning On Windows do not unpack the Eclipse installation into Program Files , because no write access is granted there, breaking both Eclipse and Spoofax.","title":"Unpack"},{"location":"tutorial/install/#running-eclipse","text":"Start up Eclipse, depending on your operating system: Windows: run Spoofax3/eclipse.exe macOS run Spoofax3.app Linux run Spoofax3/eclipse Warning macOS Sierra (10.12) and above will mark the unpacked Spoofax3.app as \"damaged\" due to a modified signed/notarized application, because we have modified the eclipse.ini file inside it. To fix this, open the Terminal, navigate to the directory where the Spoofax3.app file is located, and execute: xattr -rc Spoofax3.app After starting up, choose where your workspace will be stored. The Eclipse workspace will contain all of your settings, and is the default location for new projects.","title":"Running Eclipse"},{"location":"tutorial/install/#configuring-eclipses-preferences","text":"Some Eclipse preferences unfortunately have sub-optimal defaults. After you have chosen a workspace and Eclipse has completely started up (and you have closed the Welcome page), go to the Eclipse preferences by pressing Cmd + , on macOS and ??? on others, and set these options: General \u2023 Startup and Shutdown Enable: Refresh workspace on startup General \u2023 Workspace Enable: Refresh using native hooks or polling General \u2023 Workspace \u2023 Build Enable: Save automatically before manual build Finally, we need to make sure that Eclipse has detected an installed JRE . Open the Eclipse preferences and go to the Java \u2023 Installed JREs page: If there are no installed JREs, and you've downloaded an Eclipse installation with an embedded JVM , press Search... and navigate to the location where you unpacked the Eclipse installation, and choose the jvm directory in it. Then press the checkmark of the JRE to activate it. If there are no installed JREs, and you've downloaded an Eclipse installation without an embedded JVM , press Search... and navigate to the location where your JVM installed, and choose it. Then press the checkmark of the JRE to activate it. If there are one or more installed JVMs, but none are selected, select an appropriate one by pressing the checkmark. If there are one or more installed JVMs, and one is selected, you are good to go. Tip These preferences are stored per workspace. If you create a fresh workspace, you have to re-do these settings. You can create a new workspace with copied preferences by selecting File \u2023 Switch workspace \u2023 Other... , and then checking Preferences under Copy settings . Now that Eclipse is set up, continue with creating a language project","title":"Configuring Eclipse's preferences"}]}